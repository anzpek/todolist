import { CheckCircle2, Calendar } from 'lucide-react'
import { useState, memo, useMemo, useEffect } from 'react'
import { useTodos } from '../contexts/TodoContext'
import { useVacation } from '../contexts/VacationContext'
import { useAuth } from '../contexts/AuthContext'
import { isAdmin } from '../constants/admin'
import type { ViewType } from '../App'
import TodoItem from './TodoItem'
import VacationItem from './VacationItem'
import type { Todo, Priority, TaskType } from '../types/todo'

interface TodoListProps {
  currentView: ViewType
  searchTerm?: string
  priorityFilter?: Priority | 'all'
  typeFilter?: TaskType | 'all'
  projectFilter?: 'all' | 'longterm' | 'shortterm'
  tagFilter?: string[]
  completionDateFilter?: 'all' | 'today' | 'yesterday' | 'thisWeek' | 'lastWeek' | 'thisMonth'
  selectedDate?: Date // ì˜¤ëŠ˜ í• ì¼ ë·°ì—ì„œ ì„ íƒëœ ë‚ ì§œ
}

const TodoList = memo(({ 
  currentView, 
  searchTerm = '', 
  priorityFilter = 'all', 
  typeFilter = 'all', 
  projectFilter = 'all',
  tagFilter = [],
  completionDateFilter = 'all',
  selectedDate
}: TodoListProps) => {
  const { todos, getTodayTodos, getWeekTodos, getMonthTodos, reorderTodos } = useTodos()
  const { currentUser } = useAuth()
  const { showVacationsInTodos, getVacationsForDate, employees } = useVacation()
  const [draggedIndex, setDraggedIndex] = useState<number | null>(null)
  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null)


  // Memoized todo retrieval based on current view
  const currentTodos = useMemo((): Todo[] => {
    let result: Todo[] = []
    switch (currentView) {
      case 'today':
        result = getTodayTodos(selectedDate)
        break
      case 'week': 
        result = getWeekTodos()
        break
      case 'month':
        result = getMonthTodos()
        break
      default:
        result = todos
    }
    
    // ğŸ” ê°„ë‹¨ ë””ë²„ê¹…: ê° ë·°ì˜ ì›”ê°„ì—…ë¬´ë³´ê³  ë°ì´í„° í™•ì¸
    const monthlyReports = result.filter(t => t.title.includes('ì›”ê°„ì—…ë¬´ë³´ê³ '))
    if (monthlyReports.length > 0) {
      console.log(`ğŸ“Š ${currentView}ë·° - ì›”ê°„ì—…ë¬´ë³´ê³ :`, monthlyReports.length, 'ê°œ, priority:', monthlyReports[0]?.priority)
    }
    
    return result
  }, [currentView, selectedDate, getTodayTodos, getWeekTodos, getMonthTodos, todos])

  // Memoized filtering logic
  const filteredTodos = useMemo((): Todo[] => {
    const applyFilters = (todoList: Todo[]): Todo[] => {
    // React key ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•œ ê°•í™”ëœ ì¤‘ë³µ ì œê±°
    const seenIds = new Set<string>()
    const uniqueTodos = todoList.filter(todo => {
      if (seenIds.has(todo.id)) {
        console.warn(`âš ï¸ ì¤‘ë³µ í‚¤ ë°œê²¬ ë° ì œê±°: ${todo.id}`)
        return false
      }
      seenIds.add(todo.id)
      return true
    })
    
    if (uniqueTodos.length !== todoList.length) {
      console.warn(`âš ï¸ ì¤‘ë³µ í• ì¼ ì œê±° ì™„ë£Œ: ${todoList.length} â†’ ${uniqueTodos.length}`)
      const duplicateIds = todoList
        .map(t => t.id)
        .filter((id, index, array) => array.indexOf(id) !== index)
      console.warn('ì¤‘ë³µëœ IDë“¤:', [...new Set(duplicateIds)])
    }
    
    return uniqueTodos.filter(todo => {
      // ê²€ìƒ‰ì–´ í•„í„°
      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase()
        const matchesTitle = todo.title.toLowerCase().includes(searchLower)
        const matchesDescription = todo.description?.toLowerCase().includes(searchLower) || false
        if (!matchesTitle && !matchesDescription) return false
      }

      // ìš°ì„ ìˆœìœ„ í•„í„°
      if (priorityFilter !== 'all' && todo.priority !== priorityFilter) {
        return false
      }

      // íƒ€ì… í•„í„°
      if (typeFilter !== 'all' && todo.type !== typeFilter) {
        return false
      }

      // í”„ë¡œì íŠ¸ í•„í„° (í”„ë¡œì íŠ¸ íƒ€ì…ì¼ ë•Œë§Œ)
      if (projectFilter !== 'all' && todo.type === 'project' && todo.project !== projectFilter) {
        return false
      }

      return true
    })
    }
    
    return applyFilters(currentTodos)
  }, [currentTodos, searchTerm, priorityFilter, typeFilter, projectFilter, tagFilter, completionDateFilter])
  // ì™„ë£Œë˜ì§€ ì•Šì€ í• ì¼: ë©”ì¸ í• ì¼ì´ ì™„ë£Œë˜ì§€ ì•Šì€ ëª¨ë“  í• ì¼
  const incompleteTodos = filteredTodos.filter(todo => !todo.completed)

  // ì™„ë£Œëœ í• ì¼: ë©”ì¸ í• ì¼ì´ ì™„ë£Œëœ ê²ƒë“¤ë§Œ (ì„œë¸ŒíƒœìŠ¤í¬ëŠ” ë³„ë„ ì²˜ë¦¬)
  const completedMainTodos = filteredTodos.filter(todo => todo.completed)

  // ì˜¤ëŠ˜ ì™„ë£Œëœ ì„œë¸ŒíƒœìŠ¤í¬ë“¤ì„ ê°œë³„ í•­ëª©ìœ¼ë¡œ ì¶”ì¶œ (ì˜¤ëŠ˜ ë·°ì—ì„œë§Œ)
  const completedSubTasksAsItems: Array<Todo & { isSubTask: true, parentTitle: string, parentDescription?: string }> = []
  
  if (currentView === 'today') {
    const today = selectedDate || new Date()
    today.setHours(0, 0, 0, 0)
    
    filteredTodos.forEach(todo => {
      if (todo.subTasks && todo.subTasks.length > 0) {
        todo.subTasks.forEach(subTask => {
          if (subTask.completed && subTask.completedAt && subTask.completedAt !== null) {
            try {
              const subTaskCompletedDate = new Date(subTask.completedAt)
              subTaskCompletedDate.setHours(0, 0, 0, 0)
              
              if (subTaskCompletedDate.getTime() === today.getTime()) {
                completedSubTasksAsItems.push({
                  ...subTask,
                  type: 'simple' as const,
                  recurrence: 'none' as const,
                  isSubTask: true,
                  parentTitle: todo.title,
                  parentDescription: todo.description,
                  createdAt: subTask.createdAt,
                  updatedAt: subTask.updatedAt
                })
              }
            } catch {
              // ë‚ ì§œ íŒŒì‹± ì˜¤ë¥˜ ë¬´ì‹œ
            }
          }
        })
      }
    })
  }

  // ì™„ë£Œëœ í• ì¼ = ì™„ë£Œëœ ë©”ì¸ í• ì¼ + ì˜¤ëŠ˜ ì™„ë£Œëœ ì„œë¸ŒíƒœìŠ¤í¬ í•­ëª©ë“¤
  const allCompletedItems = [...completedMainTodos, ...completedSubTasksAsItems]

  // íœ´ê°€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ê´€ë¦¬ìì´ê³  íœ´ê°€ í‘œì‹œê°€ í™œì„±í™”ëœ ê²½ìš°)
  const getDisplayDate = () => {
    if (currentView === 'today' && selectedDate) {
      return selectedDate
    }
    return new Date() // ê¸°ë³¸ì ìœ¼ë¡œ ì˜¤ëŠ˜ ë‚ ì§œ
  }

  const shouldShowVacations = isAdmin(currentUser?.email) && showVacationsInTodos
  const vacationsForDate = shouldShowVacations ? getVacationsForDate(getDisplayDate()) : []

  const handleDragStart = (e: React.DragEvent, index: number) => {
    console.log('ğŸ”¥ ë“œë˜ê·¸ ì‹œì‘:', index, sortedIncompleteTodos[index]?.title)
    
    setDraggedIndex(index)
    e.dataTransfer.effectAllowed = 'move'
    e.dataTransfer.setData('text/plain', index.toString())
  }

  const handleDragOver = (e: React.DragEvent, hoverIndex?: number) => {
    e.preventDefault()
    e.stopPropagation()
    e.dataTransfer.dropEffect = 'move'
    
    if (hoverIndex !== undefined && hoverIndex !== dragOverIndex) {
      setDragOverIndex(hoverIndex)
    }
  }

  const handleDrop = async (e: React.DragEvent, dropIndex: number) => {
    e.preventDefault()
    console.log('ğŸ¯ ë“œë¡­ ì‹œë„:', draggedIndex, 'â†’', dropIndex)
    console.log('ğŸ“‹ ë“œë˜ê·¸ëœ í• ì¼:', sortedIncompleteTodos[draggedIndex!]?.title)
    console.log('ğŸ“‹ ë“œë¡­ë  ìœ„ì¹˜:', dropIndex, dropIndex < sortedIncompleteTodos.length ? `${sortedIncompleteTodos[dropIndex]?.title} ìœ„` : 'ë§¨ ë')
    
    if (draggedIndex === null) return
    
    try {
      if (draggedIndex !== dropIndex) {
        // ì•„ë˜ë¡œ ë“œë˜ê·¸í•˜ëŠ” ê²½ìš° ë°°ì—´ ì¡°ì‘ íŠ¹ì„±ìƒ dropIndexë¥¼ 1 ê°ì†Œì‹œì¼œì•¼ í•¨
        let adjustedDropIndex = dropIndex
        if (dropIndex > draggedIndex) {
          adjustedDropIndex = dropIndex - 1
          console.log(`â¬‡ï¸ ì•„ë˜ë¡œ ë“œë˜ê·¸: dropIndex ${dropIndex} â†’ ${adjustedDropIndex}`)
        }
        
        // ì˜ˆìƒ ê²°ê³¼ ë¯¸ë¦¬ ê³„ì‚°í•´ì„œ ë¡œê·¸
        const testArray = Array.from(sortedIncompleteTodos)
        const [removed] = testArray.splice(draggedIndex, 1)
        testArray.splice(adjustedDropIndex, 0, removed)
        
        console.log('ğŸ”„ ì˜ˆìƒ ê²°ê³¼:')
        testArray.forEach((todo, index) => {
          console.log(`  ${index}: ${todo.title}`)
        })
        
        await reorderTodos(draggedIndex, adjustedDropIndex, sortedIncompleteTodos)
        console.log('âœ… ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì„±ê³µ')
      }
    } catch (error) {
      console.error('âŒ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì €ì¥ ì‹¤íŒ¨:', error)
    }
    
    // ìƒíƒœ ì´ˆê¸°í™”
    setDraggedIndex(null)
    setDragOverIndex(null)
  }

  const handleDragEnd = () => {
    setDraggedIndex(null)
    setDragOverIndex(null)
  }

  // ìš°ì„ ìˆœìœ„ë³„ë¡œ ì •ë ¬ (ê¸´ê¸‰ > ë†’ìŒ > ë³´í†µ > ë‚®ìŒ)
  const sortByPriority = (todos: Todo[]): Todo[] => {
    const priorityOrder = { urgent: 0, high: 1, medium: 2, low: 3 }
    
    const sorted = todos.sort((a, b) => {
      // ğŸ”¥ ìš°ì„ ìˆœìœ„ê°€ ë‹¤ë¥´ë©´ ìš°ì„ ìˆœìœ„ë¡œë§Œ ì •ë ¬
      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority]
      if (priorityDiff !== 0) {
        console.log(`ğŸ¯ ìš°ì„ ìˆœìœ„ ì •ë ¬: ${a.title}(${a.priority}) vs ${b.title}(${b.priority}) â†’ ${priorityDiff}`)
        return priorityDiff
      }
      
      // ğŸ”¥ ê°™ì€ ìš°ì„ ìˆœìœ„ ë‚´ì—ì„œë§Œ order ê°’ìœ¼ë¡œ ì •ë ¬
      const orderA = a.order
      const orderB = b.order
      
      // ë‘˜ ë‹¤ order ê°’ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ orderë¡œ ì •ë ¬
      if (orderA !== undefined && orderB !== undefined) {
        if (orderA !== orderB) {
          console.log(`ğŸ“Š ê°™ì€ ìš°ì„ ìˆœìœ„ ë‚´ order ì •ë ¬: ${a.title}(${orderA}) vs ${b.title}(${orderB})`)
          return orderA - orderB
        }
      }
      
      // ğŸ”¥ ê°™ì€ ìš°ì„ ìˆœìœ„ì—ì„œ í•œìª½ë§Œ orderê°€ ìˆëŠ” ê²½ìš° - ìš°ì„ ìˆœìœ„ê°€ ê°™ìœ¼ë¯€ë¡œ order ìš°ì„ 
      if (orderA !== undefined && orderB === undefined) return -1
      if (orderA === undefined && orderB !== undefined) return 1
      
      // orderê°€ ê°™ì€ ê²½ìš°(ë‘˜ ë‹¤ ì—†ê±°ë‚˜ ê°™ì€ ê°’)ì—ë§Œ ì¶”ê°€ ì •ë ¬ ê¸°ì¤€ ì ìš©
      
      // ë§ˆê°ì¼ì´ ìˆëŠ” ê²ƒ ìš°ì„ 
      if (a.dueDate && b.dueDate) {
        return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()
      }
      if (a.dueDate) return -1
      if (b.dueDate) return 1
      
      // ë‘˜ ë‹¤ orderê°€ ì—†ê³  ë§ˆê°ì¼ë„ ì—†ìœ¼ë©´ ìƒì„±ì¼ ì—­ìˆœ (ìµœì‹ ì´ ìœ„ìª½)
      return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    })
    
    return sorted
  }

  const sortedIncompleteTodos = sortByPriority(incompleteTodos)
  
  // ì •ë ¬ëœ í• ì¼ ì‚¬ìš©
  const displayTodos = sortedIncompleteTodos
  
  // ì™„ë£Œëœ í• ì¼ ì •ë ¬ (ì™„ë£Œ ì‹œê°„ ê¸°ì¤€ ìµœì‹ ìˆœ)
  const sortedCompletedTodos = allCompletedItems.sort((a, b) => {
    const getCompletedTime = (item: any) => {
      // ì„œë¸ŒíƒœìŠ¤í¬ì¸ ê²½ìš° completedAt ì‚¬ìš©
      if ((item as any).isSubTask && item.completedAt) {
        try {
          return new Date(item.completedAt).getTime()
        } catch {
          return 0
        }
      }
      // ì¼ë°˜ í• ì¼ì¸ ê²½ìš° completedAt ë˜ëŠ” updatedAt ì‚¬ìš©
      if (item.completedAt) {
        try {
          return new Date(item.completedAt).getTime()
        } catch {
          return new Date(item.updatedAt).getTime()
        }
      }
      return new Date(item.updatedAt).getTime()
    }
    
    return getCompletedTime(b) - getCompletedTime(a) // ìµœì‹ ìˆœ ì •ë ¬
  })

  if (filteredTodos.length === 0 && vacationsForDate.length === 0) {
    return (
      <div className="card p-8 text-center text-gray-500 dark:text-gray-400">
        <p className="text-lg mb-2">í• ì¼ì´ ì—†ìŠµë‹ˆë‹¤</p>
        <p>ìƒˆë¡œìš´ í• ì¼ì„ ì¶”ê°€í•´ë³´ì„¸ìš”!</p>
      </div>
    )
  }

  return (
    <div className="space-y-6 relative">
      {/* íœ´ê°€ ì •ë³´ ì„¹ì…˜ */}
      {vacationsForDate.length > 0 && (
        <div>
          <h3 className="text-lg font-semibold text-purple-700 dark:text-purple-300 mb-4 flex items-center gap-2">
            <Calendar className="w-5 h-5" />
            ì˜¤ëŠ˜ì˜ íœ´ê°€ ({vacationsForDate.length})
          </h3>
          <div className="space-y-2">
            {vacationsForDate.map(vacation => {
              const employee = employees.find(emp => emp.id === vacation.employeeId)
              return (
                <VacationItem
                  key={vacation.id}
                  vacation={vacation}
                  employee={employee}
                  compact={true}
                />
              )
            })}
          </div>
        </div>
      )}

      {/* ì§„í–‰ ì¤‘ì¸ í• ì¼ ì„¹ì…˜ */}
      {sortedIncompleteTodos.length > 0 && (
        <div>
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
            ì§„í–‰ ì¤‘ì¸ í• ì¼ ({sortedIncompleteTodos.length})
          </h3>
          <div 
            className="relative"
            onDragOver={(e) => {
              e.preventDefault()
              if (draggedIndex === null) return
              
              // ì „ì²´ ì»¨í…Œì´ë„ˆì—ì„œ ìœ„ì¹˜ ê³„ì‚°
              const container = e.currentTarget
              const rect = container.getBoundingClientRect()
              const y = e.clientY - rect.top
              
              // ê° ì•„ì´í…œì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ì„œ ë“œë¡­ ì¸ë±ìŠ¤ ê²°ì •
              const items = container.querySelectorAll('[data-todo-index]')
              let newDropIndex = items.length // ê¸°ë³¸ê°’: ë§¨ ë
              
              // ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê·¸
              console.log('ğŸ–±ï¸ ë§ˆìš°ìŠ¤ Y ìœ„ì¹˜:', y, 'ì „ì²´ ì•„ì´í…œ:', items.length, 'ë“œë˜ê·¸ ì¤‘ì¸ ì¸ë±ìŠ¤:', draggedIndex)
              
              // ê° ì•„ì´í…œì„ ìˆœíšŒí•˜ë©° ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì™€ ë¹„êµ
              for (let i = 0; i < items.length; i++) {
                const itemRect = items[i].getBoundingClientRect()
                const itemTop = itemRect.top - rect.top
                const itemBottom = itemRect.bottom - rect.top
                const itemMidY = itemTop + (itemBottom - itemTop) / 2
                
                console.log(`ğŸ“‹ ì•„ì´í…œ ${i}: top=${itemTop.toFixed(1)}, mid=${itemMidY.toFixed(1)}, bottom=${itemBottom.toFixed(1)}`)
                
                if (y < itemMidY) {
                  // ì•„ì´í…œì˜ ìƒë°˜ë¶€ì— ë§ˆìš°ìŠ¤ê°€ ìˆìœ¼ë©´ í•´ë‹¹ ì•„ì´í…œ ìœ„ì— ì‚½ì…
                  newDropIndex = i
                  console.log(`âœ… ì•„ì´í…œ ${i} ìƒë°˜ë¶€ì—ì„œ ë“œë¡­ ì¸ë±ìŠ¤ ê²°ì •: ${newDropIndex}`)
                  break
                }
              }
              
              console.log(`ğŸ¯ ìµœì¢… ë“œë¡­ ì¸ë±ìŠ¤: ${newDropIndex} (draggedIndex: ${draggedIndex})`)
              
              // ë³€ê²½ì´ ì—†ëŠ” ê²½ìš°ëŠ” ìŠ¤í‚µ
              if (newDropIndex === draggedIndex) {
                console.log('âŒ ìê¸° ìì‹ ì˜ ìœ„ì¹˜ì´ë¯€ë¡œ ìŠ¤í‚µ')
                setDragOverIndex(null)
                return
              }
              
              setDragOverIndex(newDropIndex)
            }}
            onDrop={(e) => {
              e.preventDefault()
              if (dragOverIndex !== null) {
                handleDrop(e, dragOverIndex)
              }
            }}
            style={{
              background: draggedIndex !== null ? 'linear-gradient(to bottom, #dbeafe 0%, #dbeafe 100%)' : 'transparent'
            }}
          >
            {sortedIncompleteTodos.map((todo, index) => {
              return (
                <div key={todo.id} className="relative">
                  {/* ë“œë¡­ ì¸ë””ì¼€ì´í„° */}
                  {draggedIndex !== null && dragOverIndex === index && (
                    <div className="absolute top-0 left-0 right-0 h-1 bg-blue-500 z-30" />
                  )}
                  
                  {/* í• ì¼ ì•„ì´í…œ */}
                  <div 
                    data-todo-index={index}
                    draggable 
                    onDragStart={(e) => handleDragStart(e, index)}
                    onDragEnd={handleDragEnd}
                    className={`
                      cursor-grab active:cursor-grabbing transition-all duration-200 relative
                      ${draggedIndex === index ? 'scale-105 shadow-lg z-20' : ''}
                      mb-1
                    `}
                  >
                    <TodoItem todo={todo} />
                  </div>
                  
                  {/* ë§ˆì§€ë§‰ ì•„ì´í…œ í›„ ë“œë¡­ ì¸ë””ì¼€ì´í„° */}
                  {draggedIndex !== null && dragOverIndex === index + 1 && index === sortedIncompleteTodos.length - 1 && (
                    <div className="absolute bottom-0 left-0 right-0 h-1 bg-blue-500 z-30" />
                  )}
                </div>
              )
            })}
          </div>
        </div>
      )}

      {sortedCompletedTodos.length > 0 && (currentView === 'today' || currentView === 'week' || currentView === 'month') && (
        <div>
          <h3 className="text-lg font-semibold text-green-700 dark:text-green-300 mb-4 flex items-center gap-2">
            <CheckCircle2 className="w-5 h-5" />
            ì™„ë£Œëœ í• ì¼ ({sortedCompletedTodos.length})
          </h3>
          <div className="space-y-2">
            {sortedCompletedTodos.map(todo => {
              // ì„œë¸ŒíƒœìŠ¤í¬ì¸ ê²½ìš° íŠ¹ë³„í•œ ì»´íŒ©íŠ¸ í‘œì‹œ
              if ((todo as any).isSubTask) {
                const subTask = todo as any
                const completedTime = subTask.completedAt ? new Date(subTask.completedAt) : new Date(subTask.updatedAt)
                
                return (
                  <div 
                    key={`subtask-${todo.id}`} 
                    className="flex items-center gap-3 p-3 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg"
                  >
                    <div className="flex-shrink-0">
                      <CheckCircle2 className="w-4 h-4 text-green-600 dark:text-green-400" />
                    </div>
                    
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2 mb-1">
                        <span className="text-sm font-medium text-green-800 dark:text-green-200 line-through">
                          {todo.title}
                        </span>
                        <span className="px-1.5 py-0.5 text-xs bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 rounded border">
                          í•˜ìœ„ì‘ì—…
                        </span>
                      </div>
                      
                      <div className="text-xs text-green-700 dark:text-green-300">
                        <span className="font-medium">ìƒìœ„ í”„ë¡œì íŠ¸:</span> {subTask.parentTitle}
                        {subTask.parentDescription && (
                          <span className="ml-2 opacity-75">â€¢ {subTask.parentDescription}</span>
                        )}
                      </div>
                      
                      <div className="text-xs text-green-600 dark:text-green-400 mt-1">
                        ì™„ë£Œì‹œê°„: {completedTime.toLocaleTimeString('ko-KR', { 
                          hour: '2-digit', 
                          minute: '2-digit' 
                        })}
                      </div>
                    </div>
                  </div>
                )
              }
              
              // ì¼ë°˜ í• ì¼
              return <TodoItem key={todo.id} todo={todo} />
            })}
          </div>
        </div>
      )}

    </div>
  )
})

TodoList.displayName = 'TodoList'

export default TodoList