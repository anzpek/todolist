import { createContext, useContext, useReducer, useEffect, useRef } from 'react'
import type { ReactNode } from 'react'
import type { Todo, SubTask, Priority, TaskType } from '../types/todo'
import type { RecurringTemplate, RecurringInstance } from '../types/context'
import { generateId } from '../utils/helpers'
import { simpleRecurringSystem, type SimpleRecurringTemplate, type SimpleRecurringInstance } from '../utils/simpleRecurring'
import { useAuth } from './AuthContext'
import { firestoreService } from '../services/firestoreService'
import { deleteField } from '../config/firebase'

interface TodoState {
  todos: Todo[]
  recurringTemplates: SimpleRecurringTemplate[]
  recurringInstances: SimpleRecurringInstance[]
  loading: boolean
  error: string | null
  syncing: boolean
}

type TodoAction = 
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_SYNCING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_TODOS'; payload: Todo[] }
  | { type: 'ADD_TODO'; payload: Todo }
  | { type: 'UPDATE_TODO'; payload: { id: string; updates: Partial<Todo> } }
  | { type: 'DELETE_TODO'; payload: string }
  | { type: 'TOGGLE_TODO'; payload: string }
  | { type: 'ADD_SUBTASK'; payload: { todoId: string; subTask: SubTask } }
  | { type: 'UPDATE_SUBTASK'; payload: { todoId: string; subTaskId: string; updates: Partial<SubTask> } }
  | { type: 'DELETE_SUBTASK'; payload: { todoId: string; subTaskId: string } }
  | { type: 'TOGGLE_SUBTASK'; payload: { todoId: string; subTaskId: string } }
  | { type: 'SET_RECURRING_TEMPLATES'; payload: SimpleRecurringTemplate[] }
  | { type: 'ADD_RECURRING_TEMPLATE'; payload: SimpleRecurringTemplate }
  | { type: 'UPDATE_RECURRING_TEMPLATE'; payload: { id: string; updates: Partial<SimpleRecurringTemplate> } }
  | { type: 'DELETE_RECURRING_TEMPLATE'; payload: string }
  | { type: 'SET_RECURRING_INSTANCES'; payload: SimpleRecurringInstance[] }
  | { type: 'UPDATE_RECURRING_INSTANCE'; payload: { id: string; updates: Partial<SimpleRecurringInstance> } }
  | { type: 'GENERATE_RECURRING_INSTANCES' }

interface TodoContextType extends TodoState {
  addTodo: (todoData: Omit<Todo, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>
  updateTodo: (id: string, updates: Partial<Todo>) => Promise<void>
  deleteTodo: (id: string) => Promise<void>
  toggleTodo: (id: string) => Promise<void>
  addSubTask: (todoId: string, title: string) => Promise<void>
  updateSubTask: (todoId: string, subTaskId: string, updates: Partial<SubTask>) => Promise<void>
  deleteSubTask: (todoId: string, subTaskId: string) => Promise<void>
  toggleSubTask: (todoId: string, subTaskId: string) => Promise<void>
  syncWithFirestore: () => Promise<void>
  getTodayTodos: (targetDate?: Date) => Todo[]
  getWeekTodos: () => Todo[]
  getMonthTodos: () => Todo[]
  getOverdueTodos: () => Todo[]
  getTomorrowTodos: (targetDate?: Date) => Todo[]
  getYesterdayIncompleteTodos: (targetDate?: Date) => Todo[]
  isYesterdayIncompleteTodo: (todo: Todo) => boolean
  updateTodoOrder: (todoId: string, newOrder: number) => Promise<void>
  reorderTodos: (sourceIndex: number, destinationIndex: number, todos: Todo[]) => Promise<void>
  getFilteredTodos: (filters: {
    searchTerm?: string
    priorityFilter?: Priority | 'all'
    typeFilter?: TaskType | 'all'
    projectFilter?: 'all' | 'longterm' | 'shortterm'
    tagFilter?: string[]
    completionDateFilter?: 'all' | 'today' | 'yesterday' | 'thisWeek' | 'lastWeek' | 'thisMonth'
    includeCompleted?: boolean
  }) => Todo[]
  // Î∞òÎ≥µ Ìï†Ïùº Í¥ÄÎ†® Ìï®ÏàòÎì§
  addRecurringTemplate: (template: Omit<SimpleRecurringTemplate, 'id' | 'createdAt' | 'updatedAt'>) => void
  updateRecurringTemplate: (id: string, updates: Partial<SimpleRecurringTemplate>) => void
  deleteRecurringTemplate: (id: string) => void
  generateRecurringInstances: () => void
  getRecurringTodos: () => Todo[]
  cleanupDuplicateTemplates: () => void
  forceRefresh: () => Promise<void>
  manualRefresh: () => Promise<void>
  initializeOrderValues: () => void
  fixRecurringInstances: () => Promise<void>
}

const TodoContext = createContext<TodoContextType | undefined>(undefined)

const initialState: TodoState = {
  todos: [],
  recurringTemplates: [],
  recurringInstances: [],
  loading: false,
  error: null,
  syncing: false
}

function todoReducer(state: TodoState, action: TodoAction): TodoState {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, loading: action.payload }
    case 'SET_SYNCING':
      return { ...state, syncing: action.payload }
    case 'SET_ERROR':
      return { ...state, error: action.payload }
    case 'SET_TODOS':
      // Ï§ëÎ≥µ Ï†úÍ±∞ ÌõÑ ÏÑ§Ï†ï
      const uniqueSetTodos = action.payload.filter((todo, index, array) => 
        array.findIndex(t => t.id === todo.id) === index
      )
      if (uniqueSetTodos.length !== action.payload.length) {
        console.warn(`‚ö†Ô∏è SET_TODOS Ï§ëÎ≥µ Ï†úÍ±∞: ${action.payload.length} ‚Üí ${uniqueSetTodos.length}`)
      }
      return { ...state, todos: uniqueSetTodos }
    case 'ADD_TODO':
      // Í∏∞Ï°¥ Ìï†ÏùºÍ≥º Ï§ëÎ≥µ Î∞©ÏßÄ
      const existsInCurrent = state.todos.some(t => t.id === action.payload.id)
      if (existsInCurrent) {
        console.warn(`‚ö†Ô∏è ADD_TODO Ï§ëÎ≥µ Î∞©ÏßÄ: ${action.payload.id} Ïù¥ÎØ∏ Ï°¥Ïû¨`)
        return state
      }
      return { ...state, todos: [action.payload, ...state.todos] }
    case 'UPDATE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, ...action.payload.updates, updatedAt: new Date() }
            : todo
        )
      }
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      }
    case 'TOGGLE_TODO': {
      const now = new Date()
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { 
                ...todo, 
                completed: !todo.completed,
                completedAt: !todo.completed ? now : undefined,
                updatedAt: now
              }
            : todo
        )
      }
    }
    case 'ADD_SUBTASK':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.todoId
            ? {
                ...todo,
                subTasks: [...(todo.subTasks || []), action.payload.subTask],
                updatedAt: new Date()
              }
            : todo
        )
      }
    case 'UPDATE_SUBTASK':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.todoId
            ? {
                ...todo,
                subTasks: todo.subTasks?.map(subTask =>
                  subTask.id === action.payload.subTaskId
                    ? { ...subTask, ...action.payload.updates, updatedAt: new Date() }
                    : subTask
                ) || [],
                updatedAt: new Date()
              }
            : todo
        )
      }
    case 'DELETE_SUBTASK':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.todoId
            ? {
                ...todo,
                subTasks: todo.subTasks?.filter(subTask => subTask.id !== action.payload.subTaskId) || [],
                updatedAt: new Date()
              }
            : todo
        )
      }
    case 'TOGGLE_SUBTASK':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.todoId
            ? {
                ...todo,
                subTasks: todo.subTasks?.map(subTask =>
                  subTask.id === action.payload.subTaskId
                    ? { ...subTask, completed: !subTask.completed, updatedAt: new Date() }
                    : subTask
                ) || [],
                updatedAt: new Date()
              }
            : todo
        )
      }
    case 'SET_RECURRING_TEMPLATES':
      return { ...state, recurringTemplates: action.payload }
    case 'ADD_RECURRING_TEMPLATE':
      return { ...state, recurringTemplates: [action.payload, ...state.recurringTemplates] }
    case 'UPDATE_RECURRING_TEMPLATE':
      return {
        ...state,
        recurringTemplates: state.recurringTemplates.map(template =>
          template.id === action.payload.id
            ? { ...template, ...action.payload.updates, updatedAt: new Date() }
            : template
        )
      }
    case 'DELETE_RECURRING_TEMPLATE':
      return {
        ...state,
        recurringTemplates: state.recurringTemplates.filter(template => template.id !== action.payload),
        recurringInstances: state.recurringInstances.filter(instance => instance.templateId !== action.payload)
      }
    case 'SET_RECURRING_INSTANCES':
      // Firebase Îç∞Ïù¥ÌÑ∞ Ïö∞ÏÑ† Î≥ëÌï© (Firebase Îç∞Ïù¥ÌÑ∞Í∞Ä Î°úÏª¨ Îç∞Ïù¥ÌÑ∞Î•º ÎçÆÏñ¥ÏîÄ)
      console.log('üîÑ SET_RECURRING_INSTANCES - Firebase Îç∞Ïù¥ÌÑ∞Î°ú state ÏóÖÎç∞Ïù¥Ìä∏')
      console.log(`   Í∏∞Ï°¥ Ïù∏Ïä§ÌÑ¥Ïä§ Ïàò: ${state.recurringInstances.length}`)
      console.log(`   ÏÉà Firebase Ïù∏Ïä§ÌÑ¥Ïä§ Ïàò: ${action.payload.length}`)
      
      // ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏÉÅÌÉú ÌôïÏù∏
      const newMonthlyReport = action.payload.find(i => i.id === 'vCyWLYn3LuDq1nVUPSyE_2025-08-26')
      if (newMonthlyReport) {
        console.log(`   üîß Firebase ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏÉÅÌÉú: completed=${newMonthlyReport.completed}`)
      }
      
      return { ...state, recurringInstances: action.payload }
    case 'UPDATE_RECURRING_INSTANCE':
      return {
        ...state,
        recurringInstances: state.recurringInstances.map(instance =>
          instance.id === action.payload.id
            ? { ...instance, ...action.payload.updates, updatedAt: new Date() }
            : instance
        )
      }
    case 'GENERATE_RECURRING_INSTANCES': {
      // Î™®Îì† ÌôúÏÑ± ÌÖúÌîåÎ¶øÏóê ÎåÄÌï¥ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
      let allInstances: SimpleRecurringInstance[] = []
      
      // localStorageÏóêÏÑú Í∏∞Ï°¥ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉÅÌÉú Î°úÎìú (ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÏö©)
      let savedInstances: SimpleRecurringInstance[] = []
      try {
        const savedData = localStorage.getItem('recurringInstances')
        if (savedData) {
          const parsed = JSON.parse(savedData)
          savedInstances = (parsed as Array<{
            id: string
            templateId: string
            date: string | Date
            completed: boolean
            completedAt?: string | Date
            skipped?: boolean
            createdAt: string | Date
            updatedAt: string | Date
          }>).map((item) => ({
            ...item,
            date: new Date(item.date),
            createdAt: new Date(item.createdAt),
            updatedAt: new Date(item.updatedAt),
            completedAt: item.completedAt ? new Date(item.completedAt) : undefined
          }))
          console.log('üìÇ localStorageÏóêÏÑú Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Î≥µÏõê:', savedInstances.length, 'Í∞ú')
        }
      } catch (error) {
        console.error('‚ùå localStorage Ïù∏Ïä§ÌÑ¥Ïä§ Î°úÎìú Ïã§Ìå®:', error)
      }
      
      // üî• Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÏôÄ ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê Î∂ÑÎ¶¨ Ï≤òÎ¶¨
      if (currentUser) {
        // Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Firebase Ïù∏Ïä§ÌÑ¥Ïä§Îßå ÏÇ¨Ïö©, Î°úÏª¨ ÏÉùÏÑ± ÎπÑÌôúÏÑ±Ìôî
        console.log('üîó Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - Firebase Ïù∏Ïä§ÌÑ¥Ïä§Îßå ÏÇ¨Ïö©, Î°úÏª¨ ÏÉùÏÑ± Í±¥ÎÑàÎõ∞Í∏∞')
        return state // Firebase Ïù∏Ïä§ÌÑ¥Ïä§Îäî Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖÏóêÏÑú Ï≤òÎ¶¨
      } else {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î°úÏª¨ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± + localStorage Î≥µÏõê
        console.log('üë§ ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - Î°úÏª¨ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± ÏãúÏûë')
        
        let allInstances: SimpleRecurringInstance[] = []
        
        state.recurringTemplates.filter(template => template.isActive).forEach(template => {
          try {
            const instances = simpleRecurringSystem.generateInstances(template)
            
            // localStorageÏóêÏÑú ÏÉÅÌÉú Î≥µÏõê
            const restoredInstances = instances.map(instance => {
              const saved = savedInstances.find(s => s.id === instance.id)
              if (saved) {
                console.log(`üîÑ localStorage Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉÅÌÉú Î≥µÏõê: ${instance.id} (ÏôÑÎ£å: ${saved.completed})`)
                return {
                  ...instance,
                  completed: saved.completed,
                  completedAt: saved.completedAt,
                  updatedAt: saved.updatedAt
                }
              }
              return instance
            })
          
            allInstances = [...allInstances, ...restoredInstances]
          } catch (error) {
            console.error(`ÌÖúÌîåÎ¶ø ${template.id} Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ïã§Ìå®:`, error)
          }
        })
        
        return { ...state, recurringInstances: allInstances }
      }
    }
    default:
      return state
  }
}

export const TodoProvider = ({ children }: { children: ReactNode }) => {
  const [state, dispatch] = useReducer(todoReducer, initialState)
  const { currentUser, loading: authLoading } = useAuth()
  
  // Íµ¨ÎèÖ Ìï®ÏàòÎì§ÏùÑ useRefÎ°ú Í¥ÄÎ¶¨ (Ï†ÑÏó≠ Ï†ëÍ∑º Í∞ÄÎä•)
  const todoUnsubscribeRef = useRef<(() => void) | null>(null)
  const templateUnsubscribeRef = useRef<(() => void) | null>(null)
  const instanceUnsubscribeRef = useRef<(() => void) | null>(null)

  // Firebase Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏÑ§Ï†ï
  useEffect(() => {
    // Ïù∏Ï¶ù Î°úÎî© Ï§ëÏù¥Î©¥ ÎåÄÍ∏∞
    if (authLoading) {
      return
    }

    if (!currentUser) {
      console.log('‚ùå ÎπÑÎ°úÍ∑∏Ïù∏ ÏÉÅÌÉú')
      loadFromLocalStorage()
      return
    }
    
    console.log('‚úÖ Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú - ÏÇ¨Ïö©Ïûê:', currentUser.uid)

    dispatch({ type: 'SET_LOADING', payload: true })
    
    // Firestore Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏãúÏûë (Í∏∞Ï°¥ Íµ¨ÎèÖ Ï†ïÎ¶¨)
    if (todoUnsubscribeRef.current) {
      todoUnsubscribeRef.current()
      todoUnsubscribeRef.current = null
    }
    if (templateUnsubscribeRef.current) {
      templateUnsubscribeRef.current()
      templateUnsubscribeRef.current = null
    }
    if (instanceUnsubscribeRef.current) {
      instanceUnsubscribeRef.current()
      instanceUnsubscribeRef.current = null
    }
    
    // ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÍ≥º Íµ¨ÎèÖÏùÑ ÎπÑÎèôÍ∏∞Î°ú Ï≤òÎ¶¨
    const initializeFirestore = async () => {
      try {
        // Î®ºÏ†Ä ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìñâ
        await migrateLocalDataToFirestore()
        
        if (!currentUser) return;

        // Í∑∏ Îã§Ïùå Íµ¨ÎèÖ ÏãúÏûë (ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÎêú Îç∞Ïù¥ÌÑ∞ Ìè¨Ìï®)
        console.log('ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å ÌõÑ Íµ¨ÎèÖ ÏãúÏûë - ÏÇ¨Ïö©Ïûê:', currentUser.uid)
        
        // 1. Firestore Ìï†Ïùº Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ (Í∞ÑÎã®ÌïòÍ≥† ÏßÅÏ†ëÏ†Å)
        console.log('üîó Firestore Ìï†Ïùº Íµ¨ÎèÖ ÏãúÏûë - ÏÇ¨Ïö©Ïûê ID:', currentUser.uid)
        
        // Firestore Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ Î≥µÏõê (UI Î≥µÍµ¨)
        console.log('üîó Firestore Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏãúÏûë - ÏÇ¨Ïö©Ïûê ID:', currentUser.uid)
        
        todoUnsubscribeRef.current = firestoreService.subscribeTodos(
          currentUser.uid,
          (todos) => {
            console.log('üì® FirestoreÏóêÏÑú Ìï†Ïùº ÏóÖÎç∞Ïù¥Ìä∏ ÏàòÏã†:', todos.length, 'Í∞ú')
            console.log('üìã FirestoreÏóêÏÑú Î°úÎìúÎêú Î™®Îì† Ìï†Ïùº ID:', todos.map(t => t.id))
            
            // Î∞îÎ°ú Ï†ÅÏö© (Ï§ëÎ≥µ Ï†úÍ±∞Îäî reducerÏóêÏÑú Ï≤òÎ¶¨)
            dispatch({ type: 'SET_TODOS', payload: todos })
            dispatch({ type: 'SET_LOADING', payload: false })
            dispatch({ type: 'SET_ERROR', payload: null })
          }
        )
        
        // 2. Firestore Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ
        templateUnsubscribeRef.current = firestoreService.subscribeRecurringTemplates(
          currentUser.uid,
          (templates) => {
            dispatch({ type: 'SET_RECURRING_TEMPLATES', payload: templates })
            console.log('Î∞òÎ≥µ ÌÖúÌîåÎ¶ø FirestoreÏóêÏÑú Î°úÎìúÎê®:', templates.length, 'Í∞ú')
          }
        )
        
        // 3. Firestore Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ
        console.log('üöÄ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏÑ§Ï†ï ÏãúÏûë...')
        
        // Î®ºÏ†Ä ÏßÅÏ†ë Îç∞Ïù¥ÌÑ∞ Ï°∞ÌöåÎ°ú ÌôïÏù∏
        console.log('üîç Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ Ï†ÑÏóê ÏßÅÏ†ë Îç∞Ïù¥ÌÑ∞ Ï°∞ÌöåÎ°ú ÌôïÏù∏...')
        console.log('üë§ ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥:')
        console.log('  UID:', currentUser.uid)
        console.log('  Email:', currentUser.email)
        console.log('  DisplayName:', currentUser.displayName)
        console.log('üìç Firestore Í≤ΩÎ°ú: users/' + currentUser.uid + '/recurringInstances')
        
        const directInstances = await firestoreService.getRecurringInstances(currentUser.uid)
        const directWeeklyReport = directInstances.find(i => i.id === 'PUH4xT3lVY5aK2vuQyUe_2025-08-21')
        if (directWeeklyReport) {
          console.log('üéØüéØüéØ ÏßÅÏ†ë Ï°∞ÌöåÌïú Ï£ºÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† Îç∞Ïù¥ÌÑ∞:')
          console.log('  completed:', directWeeklyReport.completed, typeof directWeeklyReport.completed)
          console.log('  completedAt:', directWeeklyReport.completedAt)
          console.log('  Ï†ÑÏ≤¥ Í∞ùÏ≤¥:', JSON.stringify(directWeeklyReport, null, 2))
          console.log('üìç Ìï¥Îãπ Î¨∏ÏÑúÏùò Ï†ÑÏ≤¥ Í≤ΩÎ°ú: users/' + currentUser.uid + '/recurringInstances/PUH4xT3lVY5aK2vuQyUe_2025-08-21')
        }
        
        // üî• ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏßÅÏ†ë Ï°∞Ìöå Ï∂îÍ∞Ä
        const directMonthlyReport = directInstances.find(i => i.id === 'vCyWLYn3LuDq1nVUPSyE_2025-08-26')
        if (directMonthlyReport) {
          console.log('üî•üî•üî• ÏßÅÏ†ë Ï°∞ÌöåÌïú ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† Îç∞Ïù¥ÌÑ∞:')
          console.log('  ID:', directMonthlyReport.id)
          console.log('  completed:', directMonthlyReport.completed, typeof directMonthlyReport.completed)
          console.log('  completedAt:', directMonthlyReport.completedAt)
          console.log('  updatedAt:', directMonthlyReport.updatedAt)
        } else {
          console.log('‚ùå ÏßÅÏ†ë Ï°∞ÌöåÏóêÏÑú ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå')
          console.log('üìã Ï†ÑÏ≤¥ ÏßÅÏ†ë Ï°∞Ìöå Ïù∏Ïä§ÌÑ¥Ïä§:', directInstances.map(i => i.id))
        }
        
        const instanceUnsubscribe = firestoreService.subscribeRecurringInstances(
          currentUser.uid,
          (instances) => {
            console.log('üîÑ Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ Îç∞Ïù¥ÌÑ∞ ÏàòÏã† - Í∞úÏàò:', instances.length)
            console.log('‚è∞ Íµ¨ÎèÖ ÏàòÏã† ÏãúÍ∞Å:', new Date().toISOString())
            
            // üîç ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏôÑÎ£å ÏÉÅÌÉú ÌôïÏù∏ (Í∞ÑÏÜåÌôî)
            const monthlyReports = instances.filter(i => i.templateId === 'vCyWLYn3LuDq1nVUPSyE')
            if (monthlyReports.length > 0) {
              console.log('üîÑ Firebase Íµ¨ÎèÖ - ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†:')
              monthlyReports.forEach(report => {
                console.log(`   ID: ${report.id}, ÏôÑÎ£å: ${report.completed}`)
                
                // ÌòÑÏû¨ Î°úÏª¨ ÏÉÅÌÉúÏôÄ ÎπÑÍµê
                const currentLocal = state.recurringInstances.find(i => i.id === report.id)
                if (currentLocal && currentLocal.completed !== report.completed) {
                  console.log(`   ‚ö†Ô∏è ÏÉÅÌÉú Î∂àÏùºÏπò: Î°úÏª¨(${currentLocal.completed}) vs Firebase(${report.completed})`)
                }
              })
            }
            
            dispatch({ type: 'SET_RECURRING_INSTANCES', payload: instances })
            console.log('‚úÖ Firebase Íµ¨ÎèÖ Îç∞Ïù¥ÌÑ∞ dispatch ÏôÑÎ£å')
          }
        )
        
        if (instanceUnsubscribe) {
          console.log('‚úÖ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏÑ§Ï†ï ÏÑ±Í≥µ')
          instanceUnsubscribeRef.current = instanceUnsubscribe
          
          // üîß Í∞ÑÏÜåÌôîÎêú Firebase Í∞ïÏ†ú ÎèôÍ∏∞Ìôî
          setTimeout(async () => {
            try {
              console.log('üîß Firebase Í∞ïÏ†ú ÎèôÍ∏∞Ìôî Ïã§Ìñâ...')
              const freshInstances = await firestoreService.getRecurringInstances(currentUser.uid)
              
              // ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏÉÅÌÉú ÌôïÏù∏
              const monthlyReport = freshInstances.find(i => i.id === 'vCyWLYn3LuDq1nVUPSyE_2025-08-26')
              if (monthlyReport) {
                console.log(`üîß Firebase ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†: ID=${monthlyReport.id}, ÏôÑÎ£å=${monthlyReport.completed}`)
              }
              
              // Í∞ïÏ†ú ÎèôÍ∏∞Ìôî (Firebase Îç∞Ïù¥ÌÑ∞Î•º ÏµúÏ¢Ö ÏßÑÏã§Î°ú ÏÇ¨Ïö©)
              dispatch({ type: 'SET_RECURRING_INSTANCES', payload: freshInstances })
              console.log('‚úÖ Firebase Í∞ïÏ†ú ÎèôÍ∏∞Ìôî ÏôÑÎ£å')
              
            } catch (error) {
              console.error('‚ùå Firebase Í∞ïÏ†ú ÎèôÍ∏∞Ìôî Ïã§Ìå®:', error)
            }
          }, 3000) // 3Ï¥à ÌõÑ Ïã§Ìñâ
        } else {
          console.error('‚ùå Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏÑ§Ï†ï Ïã§Ìå®')
        }
        
      } catch (error) {
        console.error('Firestore Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error)
        dispatch({ type: 'SET_LOADING', payload: false })
        dispatch({ type: 'SET_ERROR', payload: 'Firebase Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.' })
      }
    }
    
    initializeFirestore()

    // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Íµ¨ÎèÖ Ìï¥Ï†ú
    return () => {
      if (todoUnsubscribeRef.current) todoUnsubscribeRef.current()
      if (templateUnsubscribeRef.current) templateUnsubscribeRef.current()
      if (instanceUnsubscribeRef.current) instanceUnsubscribeRef.current()
    }
  }, [currentUser, authLoading])

  // Î∞òÎ≥µ ÌÖúÌîåÎ¶øÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ Ïù∏Ïä§ÌÑ¥Ïä§ Ïû¨ÏÉùÏÑ±
  useEffect(() => {
    if (state.recurringTemplates.length === 0) return
    
    console.log('üîÑ Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Î≥ÄÍ≤Ω Í∞êÏßÄ - Ïù∏Ïä§ÌÑ¥Ïä§ Ïû¨ÏÉùÏÑ± ÏãúÏûë')
    console.log('üìã ÌòÑÏû¨ ÌÖúÌîåÎ¶ø Ïàò:', state.recurringTemplates.length)
    
    const generateRecurringInstances = async () => {
      try {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î°úÏª¨ ÏÉùÏÑ±
        if (!currentUser) {
          const allInstances: RecurringInstance[] = []
          
          for (const template of state.recurringTemplates) {
            try {
              console.log(`üìù ÌÖúÌîåÎ¶ø Ï≤òÎ¶¨ Ï§ë: ${template.title}`)
              const instances = await generateSimpleRecurringInstances(template)
              allInstances.push(...instances)
              console.log(`‚úÖ ÌÖúÌîåÎ¶ø ${template.title}: ${instances.length}Í∞ú Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±`)
            } catch (error) {
              console.error(`‚ùå ÌÖúÌîåÎ¶ø ${template.title} Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ïã§Ìå®:`, error)
            }
          }
          
          console.log('üìä Ï¥ù ÏÉùÏÑ±Îêú Ïù∏Ïä§ÌÑ¥Ïä§:', allInstances.length)
          dispatch({ type: 'SET_RECURRING_INSTANCES', payload: allInstances })
          return
        }

        // Firebase ÏÇ¨Ïö©Ïûê: Í∞Å ÌÖúÌîåÎ¶øÎ≥ÑÎ°ú Ïû¨ÏÉùÏÑ±
        for (const template of state.recurringTemplates) {
          try {
            console.log(`üî• Firebase ÌÖúÌîåÎ¶ø Ïû¨ÏÉùÏÑ±: ${template.title}`)
            await firestoreService.regenerateRecurringInstances(template.id, currentUser.uid)
          } catch (error) {
            console.error(`‚ùå Firebase ÌÖúÌîåÎ¶ø ${template.title} Ïû¨ÏÉùÏÑ± Ïã§Ìå®:`, error)
          }
        }
        
        console.log('‚úÖ Î™®Îì† ÌÖúÌîåÎ¶ø Ïû¨ÏÉùÏÑ± ÏôÑÎ£å')
      } catch (error) {
        console.error('‚ùå Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Ïû¨ÏÉùÏÑ± Ïã§Ìå®:', error)
      }
    }
    
    generateRecurringInstances()
  }, [state.recurringTemplates, currentUser])

  // ÏÉàÎ°úÏö¥ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§Î•º FirebaseÏóê ÎèôÍ∏∞Ìôî
  useEffect(() => {
    if (!currentUser || state.recurringInstances.length === 0) return

    const syncInstancesToFirebase = async () => {
      try {
        console.log(`üîÑ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Firebase ÎèôÍ∏∞Ìôî ÌôïÏù∏ Ï§ë... (Ï¥ù ${state.recurringInstances.length}Í∞ú)`)
        
        // FirebaseÏóêÏÑú Í∏∞Ï°¥ Ïù∏Ïä§ÌÑ¥Ïä§ Ï°∞Ìöå
        const existingInstances = await firestoreService.getRecurringInstances(currentUser.uid)
        const existingIds = new Set(existingInstances.map(i => i.id))
        
        console.log(`üìÇ FirebaseÏóê Í∏∞Ï°¥ Ïù∏Ïä§ÌÑ¥Ïä§: ${existingInstances.length}Í∞ú`)
        console.log(`üìã Î°úÏª¨ Ïù∏Ïä§ÌÑ¥Ïä§: ${state.recurringInstances.length}Í∞ú`)

        // ÏÉàÎ°úÏö¥ Ïù∏Ïä§ÌÑ¥Ïä§Îßå FirebaseÏóê Ï∂îÍ∞Ä (Ïã§Ï†úÎ°ú ÏóÜÎäî Í≤ÉÎì§Îßå)
        const newInstances = state.recurringInstances.filter(instance => {
          const isNew = !existingIds.has(instance.id)
          if (isNew) {
            console.log(`üÜï ÏÉàÎ°úÏö¥ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞úÍ≤¨: ${instance.id} (ÎÇ†Ïßú: ${instance.date})`)
          }
          return isNew
        })
        
        if (newInstances.length > 0) {
          console.log(`üîÑ FirebaseÏóê ÏÉàÎ°úÏö¥ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ ${newInstances.length}Í∞ú Ï∂îÍ∞Ä ÏãúÏûë...`)
          
          for (const instance of newInstances) {
            try {
              // Ïù∏Ïä§ÌÑ¥Ïä§Î•º FirebaseÏóê ÎèôÏùºÌïú IDÎ°ú Ï†ÄÏû•
              const firestoreId = await firestoreService.addRecurringInstance({
                ...instance,
                // ID Ïú†ÏßÄÎ•º ÏúÑÌï¥ ÏßÅÏ†ë ÏÑ§Ï†ï (ÏùºÎ∞òÏ†ÅÏúºÎ°úÎäî FirestoreÍ∞Ä ÏÉùÏÑ±ÌïòÏßÄÎßå)
                id: instance.id
              }, currentUser.uid)
              console.log(`‚úÖ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Firebase Ï∂îÍ∞Ä ÏÑ±Í≥µ: ${instance.id} -> Firestore ID: ${firestoreId}`)
            } catch (error) {
              console.error(`‚ùå Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Firebase Ï∂îÍ∞Ä Ïã§Ìå®: ${instance.id}`, error)
            }
          }
          
          console.log(`üéâ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Firebase ÎèôÍ∏∞Ìôî ÏôÑÎ£å!`)
        } else {
          console.log(`‚úÖ Î™®Îì† Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä Ïù¥ÎØ∏ FirebaseÏóê ÎèôÍ∏∞ÌôîÎêòÏñ¥ ÏûàÏùå`)
        }
      } catch (error) {
        console.error('‚ùå Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ Firebase ÎèôÍ∏∞Ìôî Ïã§Ìå®:', error)
      }
    }

    // ÎîîÎ∞îÏö¥Ïä§: 500ms ÌõÑÏóê Ïã§Ìñâ (ÎÑàÎ¨¥ ÏûêÏ£º Ïã§ÌñâÎêòÏßÄ ÏïäÎèÑÎ°ù)
    const timeoutId = setTimeout(syncInstancesToFirebase, 500)
    return () => clearTimeout(timeoutId)
  }, [state.recurringInstances, currentUser])

  // localStorageÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú (ÎπÑÎ°úÍ∑∏Ïù∏ ÏÉÅÌÉúÏö©)
  const loadFromLocalStorage = () => {
    try {
      console.log('=== localStorageÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÏûë ===')
      
      // Î°úÍ∑∏Ïù∏Îêú Í≤ΩÏö∞ localStorage Îç∞Ïù¥ÌÑ∞ Î¨¥Ïãú (Í∞úÏù∏ Ï†ÑÏö© Î™®Îìú)
      if (currentUser) {
        console.log('üë§ Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©Ïûê - Í∞úÏù∏ Firebase Îç∞Ïù¥ÌÑ∞Îßå ÏÇ¨Ïö©')
        dispatch({ type: 'SET_TODOS', payload: [] })
        dispatch({ type: 'SET_RECURRING_TEMPLATES', payload: [] })
        dispatch({ type: 'SET_LOADING', payload: false })
        return
      }
      
      // Ìï†Ïùº Îç∞Ïù¥ÌÑ∞ Î°úÎìú (ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎßå localStorage ÏÇ¨Ïö©)
      if (!currentUser) {
        const todosJson = localStorage.getItem('todos')
        if (todosJson) {
          const parsedTodos = JSON.parse(todosJson)
          const todos = parsedTodos.map((todo: any) => ({
            ...todo,
            createdAt: new Date(todo.createdAt),
            updatedAt: new Date(todo.updatedAt),
            dueDate: todo.dueDate ? new Date(todo.dueDate) : undefined,
            startDate: todo.startDate ? new Date(todo.startDate) : undefined,
            completedAt: todo.completedAt ? new Date(todo.completedAt) : undefined
          }))
          console.log('localStorageÏóêÏÑú Ìï†Ïùº Î°úÎìú (ÎπÑÎ°úÍ∑∏Ïù∏):', todos.length, 'Í∞ú')
          dispatch({ type: 'SET_TODOS', payload: todos })
        }
      } else {
        console.log('Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©Ïûê - localStorage Ìï†Ïùº Î°úÎìú Í±¥ÎÑàÎúÄ (Firestore ÏÇ¨Ïö©)')
      }
      
      // Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Îç∞Ïù¥ÌÑ∞ Î°úÎìú (ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎßå)
      if (!currentUser) {
        const templatesJson = localStorage.getItem('recurringTemplates')
        if (templatesJson) {
          const parsedTemplates = JSON.parse(templatesJson)
          const templates = parsedTemplates.map((template: any) => ({
            ...template,
            createdAt: new Date(template.createdAt),
            updatedAt: new Date(template.updatedAt)
          }))
          console.log('localStorageÏóêÏÑú Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Î°úÎìú:', templates.length, 'Í∞ú')
          dispatch({ type: 'SET_RECURRING_TEMPLATES', payload: templates })
        }
      } else {
        console.log('üö´ Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©Ïûê - localStorage ÌÖúÌîåÎ¶ø Î°úÎìú ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî (Firestore Ï†ÑÏö©)')
      }
      
      dispatch({ type: 'SET_LOADING', payload: false })
      console.log('=== localStorage Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å ===')
    } catch (error) {
      console.error('localStorage Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'localStorage Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
      dispatch({ type: 'SET_LOADING', payload: false })
    }
  }

  // localStorageÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• (ÎπÑÎ°úÍ∑∏Ïù∏ ÏÉÅÌÉúÏö©)
  const saveToLocalStorage = () => {
    // Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©ÏûêÎäî localStorage ÏÇ¨Ïö© ÏïàÌï®
    if (currentUser) {
      console.log('Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©Ïûê - localStorage Ï†ÄÏû• Í±¥ÎÑàÎúÄ')
      return
    }
    
    try {
      localStorage.setItem('todos', JSON.stringify(state.todos))
      localStorage.setItem('recurringTemplates', JSON.stringify(state.recurringTemplates))
      console.log('localStorageÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å (ÎπÑÎ°úÍ∑∏Ïù∏)')
    } catch (error) {
      console.error('localStorage Ï†ÄÏû• Ïã§Ìå®:', error)
    }
  }

  // localStorageÏóêÏÑú FirestoreÎ°ú Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò (Í∞úÏù∏ Ï†ÑÏö© Î™®ÎìúÏóêÏÑúÎäî ÎπÑÌôúÏÑ±Ìôî)
  const migrateLocalDataToFirestore = async () => {
    if (!currentUser) return

    try {
      console.log('=== localStorage ‚Üí Firestore ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÌôïÏù∏ ===')
      
      if (!currentUser) return;

      // Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - localStorage ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî, ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í±¥ÎÑàÎúÄ
      console.log('üö´ Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - localStorage ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî, ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í±¥ÎÑàÎúÄ')
      return
      
      // ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å Ïó¨Î∂Ä ÌôïÏù∏
      const migrationFlag = localStorage.getItem(`migrated_${currentUser.uid}`)
      if (migrationFlag) {
        console.log('Ïù¥ÎØ∏ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£åÎêú ÏÇ¨Ïö©Ïûê:', currentUser.uid)
        return
      }
      
      console.log('ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏãúÏûë - ÏÇ¨Ïö©Ïûê:', currentUser.uid)
      
      // localStorageÏóêÏÑú Ìï†Ïùº Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
      const todosJson = localStorage.getItem('todos')
      const templatesJson = localStorage.getItem('recurringTemplates')
      
      if (todosJson || templatesJson) {
        console.log('ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÌï† localStorage Îç∞Ïù¥ÌÑ∞ Î∞úÍ≤¨')
        
        // Ìï†Ïùº Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
        if (todosJson) {
          const localTodos = JSON.parse(todosJson)
          if (localTodos.length > 0) {
            console.log(`${localTodos.length}Í∞úÏùò Ìï†ÏùºÏùÑ FirestoreÎ°ú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò`)
            
            // Í∞Å Ìï†ÏùºÏùÑ Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú FirestoreÏóê Ï∂îÍ∞Ä
            for (const todo of localTodos) {
              try {
                await firestoreService.addTodo({
                  ...todo,
                  createdAt: new Date(todo.createdAt),
                  updatedAt: new Date(todo.updatedAt),
                  dueDate: todo.dueDate ? new Date(todo.dueDate) : undefined,
                  startDate: todo.startDate ? new Date(todo.startDate) : undefined,
                  completedAt: todo.completedAt ? new Date(todo.completedAt) : undefined
                }, currentUser.uid)
                console.log(`Ìï†Ïùº ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏÑ±Í≥µ: ${todo.title}`)
              } catch (error) {
                console.error(`Ìï†Ïùº ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìå®: ${todo.title}`, error)
              }
            }
          }
        }
        
        // Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
        if (templatesJson) {
          const localTemplates = JSON.parse(templatesJson)
          if (localTemplates.length > 0) {
            console.log(`${localTemplates.length}Í∞úÏùò Î∞òÎ≥µ ÌÖúÌîåÎ¶øÏùÑ FirestoreÎ°ú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò`)
            
            for (const template of localTemplates) {
              try {
                await firestoreService.addRecurringTemplate({
                  ...template,
                  createdAt: new Date(template.createdAt),
                  updatedAt: new Date(template.updatedAt)
                }, currentUser.uid)
                console.log(`Î∞òÎ≥µ ÌÖúÌîåÎ¶ø ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏÑ±Í≥µ: ${template.title}`)
              } catch (error) {
                console.error(`Î∞òÎ≥µ ÌÖúÌîåÎ¶ø ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìå®: ${template.title}`, error)
              }
            }
          }
        }
        
        // ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å ÌõÑ localStorage Îç∞Ïù¥ÌÑ∞ Î∞±ÏóÖ Î∞è Ï†ïÎ¶¨
        const backupData = {
          todos: todosJson ? JSON.parse(todosJson) : [],
          recurringTemplates: templatesJson ? JSON.parse(templatesJson) : [],
          migratedAt: new Date().toISOString(),
          userId: currentUser.uid
        }
        localStorage.setItem(`migrated_backup_${currentUser.uid}`, JSON.stringify(backupData))
        
        // ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
        localStorage.setItem(`migrated_${currentUser.uid}`, new Date().toISOString())
        
        // Í∏∞Ï°¥ localStorage Îç∞Ïù¥ÌÑ∞ Ï†úÍ±∞ (ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å)
        localStorage.removeItem('todos')
        localStorage.removeItem('recurringTemplates')
        
        console.log('=== ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å: localStorage Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨Îê® ===')
      } else {
        console.log('ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÌï† localStorage Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùå')
        // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥ÎèÑ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£åÎ°ú ÌëúÏãú
        localStorage.setItem(`migrated_${currentUser.uid}`, new Date().toISOString())
      }
      
    } catch (error) {
      console.error('ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }
  
  // Î∞òÎ≥µ ÌÖúÌîåÎ¶øÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ simpleRecurringSystemÏóê ÎèôÍ∏∞Ìôî
  useEffect(() => {
    // üî• Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎäî simpleRecurringSystem ÏÇ¨Ïö© Í∏àÏßÄ!
    if (currentUser) {
      console.log('üö´ Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - simpleRecurringSystem ÎèôÍ∏∞Ìôî Ï∞®Îã®!')
      return
    }
    
    simpleRecurringSystem.setTemplates(state.recurringTemplates)
  }, [state.recurringTemplates, currentUser])

  // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÉÅÌÉúÏóêÏÑú todosÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ localStorageÏóê Ï†ÄÏû•
  useEffect(() => {
    if (!currentUser && !authLoading) {
      console.log('üì¶ localStorage Ï†ÄÏû• Ï§ë - todos Î≥ÄÍ≤Ω:', state.todos.length)
      saveToLocalStorage()
    }
  }, [state.todos, currentUser, authLoading])

  // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÉÅÌÉúÏóêÏÑú Î∞òÎ≥µ ÌÖúÌîåÎ¶øÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ localStorageÏóê Ï†ÄÏû•
  useEffect(() => {
    if (!currentUser && !authLoading) {
      console.log('üì¶ localStorage Ï†ÄÏû• Ï§ë - ÌÖúÌîåÎ¶ø Î≥ÄÍ≤Ω:', state.recurringTemplates.length)
      saveToLocalStorage()
    }
  }, [state.recurringTemplates, currentUser, authLoading])

  // FirestoreÏôÄ ÎèôÍ∏∞Ìôî
  const syncWithFirestore = async () => {
    if (!currentUser) return

    dispatch({ type: 'SET_SYNCING', payload: true })
    try {
      const todos = await firestoreService.getTodos(currentUser.uid)
      dispatch({ type: 'SET_TODOS', payload: todos })
      dispatch({ type: 'SET_ERROR', payload: null })
      
      // Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÌõÑ order Í∞íÏù¥ ÏóÜÎäî Ìï†ÏùºÎì§ Ï¥àÍ∏∞Ìôî
      setTimeout(() => {
        initializeOrderValues()
      }, 500)
      
      // ÎîîÎ≤ÑÍ∑∏Ïö©: window Í∞ùÏ≤¥Ïóê Ìï®Ïàò ÎÖ∏Ï∂ú
      if (typeof window !== 'undefined') {
        (window as any).initializeOrderValues = initializeOrderValues
        
        // Í∞ïÏ†ú Firebase ÎèôÍ∏∞Ìôî Ìï®Ïàò Ï∂îÍ∞Ä
        (window as any).forceFirebaseSync = async () => {
          if (!currentUser) {
            console.log('‚ùå Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§')
            return
          }
          
          try {
            console.log('üîß ÏàòÎèô Firebase Í∞ïÏ†ú ÎèôÍ∏∞Ìôî ÏãúÏûë...')
            const freshInstances = await firestoreService.getRecurringInstances(currentUser.uid)
            
            const monthlyReport = freshInstances.find(i => i.id === 'vCyWLYn3LuDq1nVUPSyE_2025-08-26')
            if (monthlyReport) {
              console.log('üîß ÏàòÎèô ÎèôÍ∏∞Ìôî - Firebase ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏÉÅÌÉú:', monthlyReport.completed)
            }
            
            dispatch({ type: 'SET_RECURRING_INSTANCES', payload: freshInstances })
            console.log('‚úÖ ÏàòÎèô Firebase ÎèôÍ∏∞Ìôî ÏôÑÎ£å!')
            
            // Í≤∞Í≥º ÌôïÏù∏
            setTimeout(() => {
              const afterSync = freshInstances.find(i => i.id === 'vCyWLYn3LuDq1nVUPSyE_2025-08-26')
              if (afterSync) {
                console.log('üîç ÏàòÎèô ÎèôÍ∏∞Ìôî ÌõÑ ÌôïÏù∏:', afterSync.completed)
              }
            }, 1000)
            
          } catch (error) {
            console.error('‚ùå ÏàòÎèô Firebase ÎèôÍ∏∞Ìôî Ïã§Ìå®:', error)
          }
        }
        
        console.log('üîß ÎîîÎ≤ÑÍ∑∏ Ìï®Ïàò Îì±Î°ùÎê®: window.forceFirebaseSync()')
      }
    } catch (error) {
      console.error('Firestore ÎèôÍ∏∞Ìôî Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'ÎèôÍ∏∞Ìôî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    } finally {
      dispatch({ type: 'SET_SYNCING', payload: false })
    }
  }

  // localStorage ÏÇ¨Ïö© Ï§ëÎã® - Firestore Ï†ÑÏö©

  // Ìï†Ïùº Ï∂îÍ∞Ä
  const addTodo = async (todoData: Omit<Todo, 'id' | 'createdAt' | 'updatedAt'>) => {
    console.log('addTodo Ìò∏Ï∂úÎê®:', todoData, 'ÏÇ¨Ïö©Ïûê:', currentUser?.uid)
    
    // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêòÎäî Ìï†ÏùºÏù¥ Í∞ôÏùÄ Ïö∞ÏÑ†ÏàúÏúÑ Í∑∏Î£πÏùò Îß® ÏúÑÏóê Ïò§ÎèÑÎ°ù order Í≥ÑÏÇ∞
    const getNewTodoOrder = (priority: string): number => {
      const samePriorityTodos = state.todos.filter(todo => 
        todo.priority === priority && !todo.completed
      )
      
      if (samePriorityTodos.length === 0) {
        // Ìï¥Îãπ Ïö∞ÏÑ†ÏàúÏúÑÏùò Ï≤´ Î≤àÏß∏ Ìï†ÏùºÏù∏ Í≤ΩÏö∞
        const priorityOrder = { urgent: 0, high: 1000, medium: 2000, low: 3000 }
        return priorityOrder[priority as keyof typeof priorityOrder] || 2000
      }
      
      // Í∞ôÏùÄ Ïö∞ÏÑ†ÏàúÏúÑ Ìï†ÏùºÎì§Ïùò ÏµúÏÜå order Í∞íÏùÑ Ï∞æÏïÑÏÑú Í∑∏Î≥¥Îã§ ÏûëÍ≤å ÏÑ§Ï†ï
      const minOrder = Math.min(...samePriorityTodos.map(todo => todo.order || 999))
      return Math.max(0, minOrder - 1)
    }
    
    const newTodo: Todo = {
      ...todoData,
      id: generateId(),
      createdAt: new Date(),
      updatedAt: new Date(),
      order: getNewTodoOrder(todoData.priority)
    }

    try {
      if (currentUser) {
        console.log('FirestoreÏóê Ìï†Ïùº Ï∂îÍ∞Ä Ï§ë:', newTodo.title)
        
        // FirestoreÏóê Ï†ÄÏû• (IDÎäî FirestoreÍ∞Ä ÏÉùÏÑ±)
        try {
          const firestoreId = await firestoreService.addTodo(newTodo, currentUser.uid)
          console.log('Firestore Ìï†Ïùº Ï∂îÍ∞Ä ÏÑ±Í≥µ, ID:', firestoreId)
          
          // Firestore IDÎ°ú Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
          const firestoreTodo = { ...newTodo, id: firestoreId }
          dispatch({ type: 'ADD_TODO', payload: firestoreTodo })
          console.log('‚úÖ Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å - Firestore ID ÏÇ¨Ïö©:', firestoreId)
        } catch (firestoreError) {
          console.error('Firestore Ï†ÄÏû• Ïã§Ìå®:', firestoreError)
          throw firestoreError
        }
      } else {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î©îÎ™®Î¶¨Ïóê Ï†ÄÏû• ÌõÑ localStorageÏóê Ï¶âÏãú Ï†ÄÏû•
        console.log('ÎπÑÎ°úÍ∑∏Ïù∏ Î™®Îìú: Î©îÎ™®Î¶¨Ïóê Ìï†Ïùº Ï∂îÍ∞Ä')
        dispatch({ type: 'ADD_TODO', payload: newTodo })
        
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎßå localStorage ÏÇ¨Ïö©
        console.log('üö´ Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©Ïûê - localStorage Ï†ÄÏû• ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî')
      }
    } catch (error) {
      console.error('Ìï†Ïùº Ï∂îÍ∞Ä Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'Ìï†Ïùº Ï∂îÍ∞Ä Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }

  // Ìï†Ïùº ÏóÖÎç∞Ïù¥Ìä∏
  const updateTodo = async (id: string, updates: Partial<Todo>) => {
    try {
      if (currentUser) {
        await firestoreService.updateTodo(id, updates, currentUser.uid)
      } else {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î©îÎ™®Î¶¨ÏóêÏÑú ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ localStorageÏóê ÏûêÎèô Ï†ÄÏû•
        console.log('ÎπÑÎ°úÍ∑∏Ïù∏ Î™®Îìú: Î©îÎ™®Î¶¨ÏóêÏÑú Ìï†Ïùº ÏóÖÎç∞Ïù¥Ìä∏')
        dispatch({ type: 'UPDATE_TODO', payload: { id, updates } })
        // localStorage Ï†ÄÏû•ÏùÄ useEffectÏóêÏÑú ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê®
      }
    } catch (error) {
      console.error('Ìï†Ïùº ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'Ìï†Ïùº ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }

  // Ìï†Ïùº ÏÇ≠Ï†ú (Î∞òÎ≥µ Ìï†Ïùº Ï≤òÎ¶¨ Í∞úÏÑ†)
  const deleteTodo = async (id: string) => {
    try {
      console.log('üóëÔ∏è Ìï†Ïùº ÏÇ≠Ï†ú ÏãúÏûë:', id)
      
      // Ìï†Ïùº Ï†ïÎ≥¥ ÌôïÏù∏ (Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ìè¨Ìï®)
      const todoInState = state.todos.find(t => t.id === id)
      console.log(`üìù ÏÇ≠Ï†ú ÎåÄÏÉÅ Ìï†Ïùº ÏÉÅÏÑ∏ Ï†ïÎ≥¥:`, {
        id: todoInState?.id,
        title: todoInState?.title,
        _isRecurringInstance: (todoInState as any)?._isRecurringInstance,
        _instanceId: (todoInState as any)?._instanceId,
        _templateId: (todoInState as any)?._templateId
      })
      
      // Î∞òÎ≥µ Ìï†Ïùº Ïù∏Ïä§ÌÑ¥Ïä§Ïù∏ÏßÄ ÌôïÏù∏ (ID Ìå®ÌÑ¥ ÎòêÎäî Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Î°ú)
      const isRecurringTodo = id.startsWith('recurring_') || (todoInState as any)?._isRecurringInstance
      
      if (isRecurringTodo) {
        // Î∞òÎ≥µ Ìï†Ïùº ÏÇ≠Ï†ú Ï≤òÎ¶¨
        console.log('üîÑ Î∞òÎ≥µ Ìï†Ïùº ÏÇ≠Ï†ú:', id)
        
        let instanceId = id
        
        // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í≤ΩÏö∞ Ïù∏Ïä§ÌÑ¥Ïä§ ID ÏÇ¨Ïö©
        if ((todoInState as any)?._instanceId) {
          instanceId = (todoInState as any)._instanceId
          console.log('üìã Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏóêÏÑú Ïù∏Ïä§ÌÑ¥Ïä§ ID Ï∂îÏ∂ú:', instanceId)
        } else if (id.startsWith('recurring_')) {
          // ÏÉàÎ°úÏö¥ ID ÌòïÌÉú Ï≤òÎ¶¨: recurring_instanceId_templateSuffix
          const parts = id.split('_')
          instanceId = id.replace('recurring_', '')
          
          // ÌÖúÌîåÎ¶ø Ï†ëÎØ∏ÏÇ¨Í∞Ä ÏûàÎäî Í≤ΩÏö∞ Ï†úÍ±∞
          if (parts.length > 2) {
            // recurring_instanceId_templateSuffix -> instanceIdÎßå Ï∂îÏ∂ú
            instanceId = parts.slice(1, -1).join('_')
          }
          console.log('üìã ID Ìå®ÌÑ¥ÏóêÏÑú Ïù∏Ïä§ÌÑ¥Ïä§ ID Ï∂îÏ∂ú:', instanceId)
        }
        
        // Ïù∏Ïä§ÌÑ¥Ïä§ Î∞∞Ïó¥ÏóêÏÑú Ï†úÍ±∞
        const updatedInstances = state.recurringInstances.filter(i => i.id !== instanceId)
        dispatch({ type: 'SET_RECURRING_INSTANCES', payload: updatedInstances })
        
        // Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑúÎèÑ Ï†úÍ±∞
        dispatch({ type: 'DELETE_TODO', payload: id })
        
        console.log('‚úÖ Î∞òÎ≥µ Ìï†Ïùº ÏÇ≠Ï†ú ÏôÑÎ£å:', id, '-> Ïù∏Ïä§ÌÑ¥Ïä§ ID:', instanceId)
        return
      }
      
      // ÏùºÎ∞ò Ìï†Ïùº ÏÇ≠Ï†ú Ï≤òÎ¶¨
      if (currentUser) {
        // 1. Î®ºÏ†Ä Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑú Ìï†ÏùºÏùÑ Ï∞æÏïÑÏÑú ÌôïÏù∏
        const todoInState = state.todos.find(t => t.id === id)
        if (!todoInState) {
          console.warn(`‚ö†Ô∏è Î°úÏª¨ ÏÉÅÌÉúÏóê Ìï†ÏùºÏù¥ ÏóÜÏùå: ${id}`)
          return
        }
        
        console.log(`üéØ ÏÇ≠Ï†ú ÎåÄÏÉÅ ÌôïÏù∏: ${todoInState.title} (${id})`)
        
        // 2. Í∞ôÏùÄ Ï†úÎ™©Ïùò Ï§ëÎ≥µ Ìï†ÏùºÎì§ Ï∞æÍ∏∞
        const duplicateTodos = state.todos.filter(t => 
          t.title === todoInState.title && 
          t.id !== id
        )
        
        if (duplicateTodos.length > 0) {
          console.log(`üîç Ï§ëÎ≥µ Ìï†Ïùº Î∞úÍ≤¨: ${duplicateTodos.length}Í∞ú`, duplicateTodos.map(t => t.id))
        }
        
        try {
          // 3. Î©îÏù∏ Ìï†Ïùº FirestoreÏóêÏÑú ÏÇ≠Ï†ú ÏãúÎèÑ
          console.log('üóëÔ∏è FirestoreÏóêÏÑú Ìï†Ïùº ÏÇ≠Ï†ú ÏãúÎèÑ:', id)
          await firestoreService.deleteTodo(id, currentUser.uid)
          console.log('‚úÖ Firestore Ìï†Ïùº ÏÇ≠Ï†ú ÏÑ±Í≥µ:', id)
        } catch (firestoreError: unknown) {
          // FirestoreÏóê Ìï†ÏùºÏù¥ ÏóÜÎäî Í≤ΩÏö∞ (ÎèôÍ∏∞Ìôî Î¨∏Ï†ú)
          if (firestoreError.message.includes('Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§')) {
            console.warn(`‚ö†Ô∏è FirestoreÏóê Ìï†ÏùºÏù¥ ÏóÜÏùå - Î°úÏª¨ÏóêÏÑúÎßå ÏÇ≠Ï†ú: ${id}`)
            console.log(`üìù Ìï†Ïùº Ï†ïÎ≥¥: ${todoInState.title}`)
          } else {
            // Îã§Î•∏ Firestore Ïò§Î•òÎäî Ïû¨Î∞úÏÉù
            throw firestoreError
          }
        }
        
        // 4. Ï§ëÎ≥µ Ìï†ÏùºÎì§ÎèÑ Î™®Îëê ÏÇ≠Ï†ú
        if (duplicateTodos.length > 0) {
          console.log(`üóëÔ∏è Ï§ëÎ≥µ Ìï†ÏùºÎì§ ÏÇ≠Ï†ú ÏãúÏûë: ${duplicateTodos.length}Í∞ú`)
          for (const duplicateTodo of duplicateTodos) {
            try {
              await firestoreService.deleteTodo(duplicateTodo.id, currentUser.uid)
              console.log(`‚úÖ Ï§ëÎ≥µ Ìï†Ïùº ÏÇ≠Ï†ú ÏÑ±Í≥µ: ${duplicateTodo.id}`)
            } catch (error) {
              console.warn(`‚ö†Ô∏è Ï§ëÎ≥µ Ìï†Ïùº ÏÇ≠Ï†ú Ïã§Ìå®: ${duplicateTodo.id}`, error)
            }
            
            // Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑúÎèÑ Ï†úÍ±∞
            dispatch({ type: 'DELETE_TODO', payload: duplicateTodo.id })
          }
        }
        
        // 5. Ïñ¥Îñ§ Í≤ΩÏö∞Îì† Î©îÏù∏ Ìï†ÏùºÎèÑ Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑú Ï†úÍ±∞ (ÎèôÍ∏∞Ìôî Î≥¥Ïû•)
        console.log('üóëÔ∏è Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑú Ìï†Ïùº Ï†úÍ±∞:', id)
        dispatch({ type: 'DELETE_TODO', payload: id })
        
        // 6. ÏÇ≠Ï†ú ÏôÑÎ£å Î°úÍ∑∏ (Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖÏù¥ ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Ìï®)
        console.log('‚úÖ ÏÇ≠Ï†ú ÏôÑÎ£å - Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖÏù¥ ÏûêÎèôÏúºÎ°ú UI ÏóÖÎç∞Ïù¥Ìä∏Ìï®')
        
        console.log('‚úÖ Ìï†Ïùº ÏÇ≠Ï†ú ÏôÑÎ£å (Î°úÏª¨ + Firestore + Ï§ëÎ≥µ Ï†úÍ±∞ + Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ®)')
        
      } else {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Í∞ÑÎã®ÌïòÍ≤å Î©îÎ™®Î¶¨ÏóêÏÑú ÏÇ≠Ï†ú
        console.log('ÎπÑÎ°úÍ∑∏Ïù∏ Î™®Îìú: Ìï†Ïùº ÏÇ≠Ï†ú:', id)
        dispatch({ type: 'DELETE_TODO', payload: id })
        console.log('‚úÖ ÎπÑÎ°úÍ∑∏Ïù∏ Ìï†Ïùº ÏÇ≠Ï†ú ÏôÑÎ£å')
      }
    } catch (error) {
      console.error('Ìï†Ïùº ÏÇ≠Ï†ú Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'Ìï†Ïùº ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
      
      // ÏóêÎü¨ Î∞úÏÉù Ïãú UI ÏÉÅÌÉú Î°§Î∞± (Firestore Ïã§Ìå® Ïãú)
      if (currentUser && !id.startsWith('recurring_')) {
        console.log('üîÑ ÏÇ≠Ï†ú Ïã§Ìå®Î°ú Ïù∏Ìïú UI Î°§Î∞±')
        const freshTodos = await firestoreService.getTodos(currentUser.uid)
        dispatch({ type: 'SET_TODOS', payload: freshTodos })
      }
    }
  }

  // Ìï†Ïùº ÌÜ†Í∏Ä
  const toggleTodo = async (id: string) => {
    console.log('üìù Ìï†Ïùº ÌÜ†Í∏Ä ÏãúÏûë:', id)
    
    // üî• ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÌÜ†Í∏Ä ÌäπÎ≥Ñ Ï∂îÏ†Å
    if (id.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†') || id.includes('vCyWLYn3LuDq1nVUPSyE')) {
      console.log('üî•üî•üî• ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÌÜ†Í∏Ä ÏãúÏûë!')
      console.log('  ÌÜ†Í∏Ä ÎåÄÏÉÅ ID:', id)
    }
    
    // Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§Ïù∏ÏßÄ ÌôïÏù∏ (_isRecurringInstance Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©)
    const allTodos = [...state.todos, ...getRecurringTodos()]
    const targetTodo = allTodos.find(t => t.id === id)
    
    // Í∏∞Í∞Ñ Ìï†Ïùº ÌäπÎ≥Ñ Ï≤òÎ¶¨: ÏãúÏûëÏùºÍ≥º ÎßàÍ∞êÏùºÏù¥ Î™®Îëê ÏûàÎäî ÏùºÎ∞ò Ìï†Ïùº
    const periodTodo = state.todos.find(t => t.id === id)
    if (periodTodo && periodTodo.startDate && periodTodo.dueDate && !(periodTodo as any)._isRecurringInstance) {
      console.log('üìÖ Í∏∞Í∞Ñ Ìï†Ïùº ÌÜ†Í∏Ä:', id, 'ÏãúÏûëÏùº:', periodTodo.startDate, 'ÎßàÍ∞êÏùº:', periodTodo.dueDate)
      
      const updates: Partial<Todo> & { completedAt?: Date | ReturnType<typeof deleteField> } = {
        completed: !periodTodo.completed,
        ...(
          !periodTodo.completed 
            ? { completedAt: new Date() }
            : { completedAt: deleteField() }
        )
      }

      try {
        // Î®ºÏ†Ä Î°úÏª¨ ÏÉÅÌÉúÎ•º Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
        dispatch({ type: 'TOGGLE_TODO', payload: id })
        
        // Firestore ÏóÖÎç∞Ïù¥Ìä∏
        if (currentUser) {
          await firestoreService.updateTodo(id, updates, currentUser.uid)
          console.log('‚úÖ Í∏∞Í∞Ñ Ìï†Ïùº Firestore ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ:', id)
        } else {
          console.log('‚úÖ ÎπÑÎ°úÍ∑∏Ïù∏ Î™®Îìú: Í∏∞Í∞Ñ Ìï†Ïùº Î©îÎ™®Î¶¨ÏóêÏÑú ÌÜ†Í∏Ä')
        }
        
        console.log(`‚úÖ Í∏∞Í∞Ñ Ìï†Ïùº ÌÜ†Í∏Ä ÏôÑÎ£å: ${id}`)
        return
      } catch (error: unknown) {
        console.error('‚ùå Í∏∞Í∞Ñ Ìï†Ïùº ÌÜ†Í∏Ä Ïã§Ìå®:', error)
        // ÏóêÎü¨ Î∞úÏÉùÏãú Ïù¥Ï†Ñ ÏÉÅÌÉúÎ°ú ÎêòÎèåÎ¶º
        dispatch({ type: 'TOGGLE_TODO', payload: id })
        dispatch({ type: 'SET_ERROR', payload: 'Ìï†Ïùº ÏÉÅÌÉú Î≥ÄÍ≤Ω Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
        return
      }
    }
    
    if (targetTodo && (targetTodo as any)._isRecurringInstance) {
      console.log('üîÑ Î∞òÎ≥µ Ìï†Ïùº ÌÜ†Í∏Ä:', id)
      
      // Ïù∏Ïä§ÌÑ¥Ïä§ ID Ï∂îÏ∂ú: recurring_ Ï†ëÎëêÏÇ¨ Ï†úÍ±∞
      let instanceId = (targetTodo as any)._instanceId
      
      // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏóêÏÑú Ïù∏Ïä§ÌÑ¥Ïä§ IDÎ•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÎäî Í≤ΩÏö∞ IDÏóêÏÑú ÏßÅÏ†ë Ï∂îÏ∂ú
      if (!instanceId && id.startsWith('recurring_')) {
        instanceId = id.replace('recurring_', '')
        console.log('üìç IDÏóêÏÑú Ïù∏Ïä§ÌÑ¥Ïä§ ID Ï∂îÏ∂ú:', instanceId)
      } else {
        console.log('üìç Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏóêÏÑú Ïù∏Ïä§ÌÑ¥Ïä§ ID:', instanceId)
      }
      
      const instance = state.recurringInstances.find(i => i.id === instanceId)
      
      if (instance) {
        console.log('‚úÖ Í∏∞Ï°¥ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞úÍ≤¨:', instance)
        const updatedInstance = {
          ...instance,
          completed: !instance.completed,
          completedAt: !instance.completed ? new Date() : undefined,
          updatedAt: new Date()
        }
        
        // FirebaseÏóê Ï†ÄÏû• ÌõÑ Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖÏúºÎ°ú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (ÎèôÍ∏∞Ìôî Î¨∏Ï†ú Ìï¥Í≤∞)
        if (currentUser) {
          try {
            console.log(`üîÑ FirebaseÏóê Í∏∞Ï°¥ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë: ${instanceId}`)
            console.log(`üìã ÏóÖÎç∞Ïù¥Ìä∏ Îç∞Ïù¥ÌÑ∞:`, {
              completed: updatedInstance.completed,
              completedAt: updatedInstance.completedAt
            })
            
            const updateData: any = {
              completed: updatedInstance.completed
            }
            
            // completedAt Ï≤òÎ¶¨: undefinedÎ©¥ null, ÏïÑÎãàÎ©¥ Date Í∞ùÏ≤¥ Ï†ÄÏû•
            if (updatedInstance.completedAt === undefined) {
              console.log('üóëÔ∏è completedAtÏù¥ undefined -> null ÏÇ¨Ïö©')
              updateData.completedAt = null
            } else {
              console.log('üìÖ completedAt ÏÑ§Ï†ï:', updatedInstance.completedAt)
              updateData.completedAt = updatedInstance.completedAt
            }
            
            console.log('üìã ÏµúÏ¢Ö ÏóÖÎç∞Ïù¥Ìä∏ Îç∞Ïù¥ÌÑ∞:', updateData)
            
            // üîß Ï¶âÏãú UI Î∞òÏùëÏùÑ ÏúÑÌïú ÏûÑÏãú Î°úÏª¨ ÏóÖÎç∞Ïù¥Ìä∏ (Firebase Íµ¨ÎèÖÏù¥ Í≥ß ÎçÆÏñ¥ÏîÄ)
            console.log('‚ö° Ï¶âÏãú UI Î∞òÏùëÏùÑ ÏúÑÌïú ÏûÑÏãú Î°úÏª¨ ÏóÖÎç∞Ïù¥Ìä∏')
            const updatedInstances = state.recurringInstances.map(i => i.id === instanceId ? updatedInstance : i)
            dispatch({ 
              type: 'SET_RECURRING_INSTANCES', 
              payload: updatedInstances
            })
            console.log('‚úÖ ÏûÑÏãú Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å (Firebase Íµ¨ÎèÖÏù¥ ÏµúÏ¢Ö ÌôïÏù∏)')
            
            // Firebase ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ
            console.log(`üîÑ Firestore ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ - instanceId: ${instanceId}`)
            console.log(`üìã Ï†ÑÏÜ°Ìï† Îç∞Ïù¥ÌÑ∞:`, updateData)
            console.log(`‚è∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë ÏãúÍ∞Å: ${new Date().toISOString()}`)
            
            await firestoreService.updateRecurringInstance(instanceId, updateData, currentUser.uid)
            
            console.log('‚úÖ Î∞òÎ≥µ Ìï†Ïùº ÏÉÅÌÉú FirebaseÏóê Ï†ÄÏû• ÏôÑÎ£å')
            console.log(`‚è∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å ÏãúÍ∞Å: ${new Date().toISOString()}`)
            
            // ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏôÑÎ£å ÏÉÅÌÉú Í∞ÑÎã® ÌôïÏù∏
            if (targetTodo?.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')) {
              console.log('‚úÖ ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏôÑÎ£å Î≥ÄÍ≤Ω:', updatedInstance.completed)
            }
            
            // Ï£ºÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÌäπÎ≥Ñ Î°úÍπÖ
            if (instanceId.includes('weekly_work_report')) {
              console.log(`üîç Ï£ºÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† Firestore ÏóÖÎç∞Ïù¥Ìä∏: completed=${updateData.completed}`)
            }
            
            // ‚ú® Firestore ÎèôÍ∏∞Ìôî ÎåÄÍ∏∞ Ï†úÍ±∞ - Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖÏúºÎ°úÎßå ÎèôÍ∏∞Ìôî (completion state Ï∂©Îèå Î∞©ÏßÄ)
            console.log('‚úÖ Firestore ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å - Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏùòÏ°¥')
            
          } catch (error) {
            console.error('‚ùå Firebase Ï†ÄÏû• Ïã§Ìå®:', error)
            // Firebase Ï†ÄÏû• Ïã§Ìå® Ïãú Î°úÏª¨ ÏÉÅÌÉúÎ•º ÏõêÎûòÎåÄÎ°ú ÎêòÎèåÎ¶¨Í∏∞
            dispatch({ 
              type: 'SET_RECURRING_INSTANCES', 
              payload: state.recurringInstances
            })
            dispatch({ type: 'SET_ERROR', payload: 'Î∞òÎ≥µ Ìï†Ïùº ÏÉÅÌÉú Î≥ÄÍ≤Ω Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
          }
        } else {
          // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î©îÎ™®Î¶¨ ÏÉÅÌÉúÎßå ÏóÖÎç∞Ïù¥Ìä∏ (localStorage ÏÇ¨Ïö© ÏïàÌï®)
          const updatedInstances = state.recurringInstances.map(i => i.id === instanceId ? updatedInstance : i)
          dispatch({ 
            type: 'SET_RECURRING_INSTANCES', 
            payload: updatedInstances
          })
          console.log('üö´ ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - localStorage ÏÇ¨Ïö© ÎπÑÌôúÏÑ±Ìôî, Î©îÎ™®Î¶¨Îßå ÏóÖÎç∞Ïù¥Ìä∏')
        }
        
        console.log('‚úÖ Í∏∞Ï°¥ Î∞òÎ≥µ Ìï†Ïùº ÌÜ†Í∏Ä ÏôÑÎ£å')
        return
      } else {
        console.log('üìù Î°úÏª¨ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏóÜÏùå. ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±:', instanceId)
        
        // Ïù∏Ïä§ÌÑ¥Ïä§ IDÏóêÏÑú ÌÖúÌîåÎ¶ø IDÏôÄ ÎÇ†Ïßú Ï∂îÏ∂ú
        const idParts = instanceId.split('_')
        if (idParts.length >= 2) {
          const templateId = idParts[0]
          const dateStr = idParts.slice(1).join('_') // ÎÇ†Ïßú Î∂ÄÎ∂Ñ Ïû¨Ï°∞Ìï©
          
          // Ìï¥Îãπ ÌÖúÌîåÎ¶ø Ï∞æÍ∏∞
          const template = state.recurringTemplates.find(t => t.id === templateId)
          
          if (template) {
            console.log('‚úÖ ÌÖúÌîåÎ¶ø Î∞úÍ≤¨:', template)
            
            // ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
            const newInstance = {
              id: instanceId,
              templateId: templateId,
              date: new Date(dateStr),
              completed: true, // Ï≤òÏùå ÌÜ†Í∏ÄÏù¥ÎØÄÎ°ú ÏôÑÎ£åÎ°ú ÏÑ§Ï†ï
              completedAt: new Date(),
              createdAt: new Date(),
              updatedAt: new Date()
            }
            
            // FirebaseÏóê Ï†ÄÏû• ÌõÑ Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖÏúºÎ°ú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            if (currentUser) {
              try {
                console.log(`üîÑ FirebaseÏóê ÏÉà Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ï§ë: ${instanceId}`)
                console.log(`üìã ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ Îç∞Ïù¥ÌÑ∞:`, newInstance)
                
                // Î®ºÏ†Ä ÎÇôÍ¥ÄÏ†Å ÏóÖÎç∞Ïù¥Ìä∏ (Ï¶âÍ∞ÅÏ†ÅÏù∏ UI Î∞òÏùëÏÑ±)
                const updatedInstances = [...state.recurringInstances, newInstance]
                dispatch({ 
                  type: 'SET_RECURRING_INSTANCES', 
                  payload: updatedInstances
                })
                console.log('‚úÖ ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ ÎÇôÍ¥ÄÏ†Å Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å')
                
                // FirebaseÏóê Ï†ÄÏû•
                await firestoreService.updateRecurringInstance(instanceId, {
                  templateId: newInstance.templateId,
                  date: newInstance.date,
                  completed: newInstance.completed,
                  completedAt: newInstance.completedAt
                  // createdAt, updatedAtÏùÄ Firestore ÏÑúÎπÑÏä§ÏóêÏÑú serverTimestamp()Î°ú ÏûêÎèô ÏÑ§Ï†ï
                }, currentUser.uid)
                console.log('‚úÖ ÏÉà Î∞òÎ≥µ Ìï†Ïùº Ïù∏Ïä§ÌÑ¥Ïä§ FirebaseÏóê ÏÉùÏÑ± ÏôÑÎ£å')
                
                // ‚ú® ÏàòÎèô ÏÉàÎ°úÍ≥†Ïπ® ÎπÑÌôúÏÑ±Ìôî - Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖÏúºÎ°úÎßå ÎèôÍ∏∞Ìôî (completion state Ï∂©Îèå Î∞©ÏßÄ)
                console.log('üîÑ ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ ÏàòÎèô ÏÉàÎ°úÍ≥†Ïπ® ÎπÑÌôúÏÑ±Ìôî - Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏùòÏ°¥')
                
              } catch (error) {
                console.error('‚ùå ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ Firebase ÏÉùÏÑ± Ïã§Ìå®:', error)
                // Firebase Ï†ÄÏû• Ïã§Ìå® Ïãú Î°úÏª¨ ÏÉÅÌÉúÎ•º ÏõêÎûòÎåÄÎ°ú ÎêòÎèåÎ¶¨Í∏∞
                dispatch({ 
                  type: 'SET_RECURRING_INSTANCES', 
                  payload: state.recurringInstances
                })
                dispatch({ type: 'SET_ERROR', payload: 'ÏÉà Î∞òÎ≥µ Ìï†Ïùº Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
              }
            } else {
              // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î©îÎ™®Î¶¨ ÏÉÅÌÉúÎßå ÏóÖÎç∞Ïù¥Ìä∏ (localStorage ÏÇ¨Ïö© ÏïàÌï®)
              const updatedInstances = [...state.recurringInstances, newInstance]
              dispatch({ 
                type: 'SET_RECURRING_INSTANCES', 
                payload: updatedInstances
              })
              console.log('üö´ ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - localStorage ÏÇ¨Ïö© ÎπÑÌôúÏÑ±Ìôî, Î©îÎ™®Î¶¨Îßå ÏóÖÎç∞Ïù¥Ìä∏')
            }
            
            console.log('‚úÖ ÏÉà Î∞òÎ≥µ Ìï†Ïùº ÌÜ†Í∏Ä ÏôÑÎ£å')
            return
          } else {
            console.error('‚ùå ÌÖúÌîåÎ¶øÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå:', templateId)
          }
        } else {
          console.error('‚ùå Ïù∏Ïä§ÌÑ¥Ïä§ ID ÌòïÏãùÏù¥ ÏûòÎ™ªÎê®:', instanceId)
        }
        
        console.error('‚ùå Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå:', instanceId)
        console.log('üìã ÌòÑÏû¨ Ïù∏Ïä§ÌÑ¥Ïä§ Î™©Î°ù:', state.recurringInstances.map(i => i.id))
        console.log('üìã ÌòÑÏû¨ ÌÖúÌîåÎ¶ø Î™©Î°ù:', state.recurringTemplates.map(t => t.id))
        return
      }
    }

    // ÏùºÎ∞ò Ìï†Ïùº Ï≤òÎ¶¨
    const basicTodo = state.todos.find(t => t.id === id)
    if (!basicTodo) {
      console.error('Todo not found:', id)
      return
    }

    const updates: Partial<Todo> & { completedAt?: Date | ReturnType<typeof deleteField> } = {
      completed: !basicTodo.completed,
      ...(
        !basicTodo.completed 
          ? { completedAt: new Date() }
          : { completedAt: deleteField() }
      )
    }

    try {
      // Î®ºÏ†Ä Î°úÏª¨ ÏÉÅÌÉúÎ•º Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
      dispatch({ type: 'TOGGLE_TODO', payload: id })
      
      // Î∞òÎ≥µ Ìï†ÏùºÏù∏ÏßÄ ÌôïÏù∏ (recurring_ ÎòêÎäî _isRecurringInstance Ï≤¥ÌÅ¨)
      const allTodosForCheck = [...state.todos, ...getRecurringTodos()]
      const todoForCheck = allTodosForCheck.find(t => t.id === id)
      const isRecurringTodo = id.startsWith('recurring_') || (todoForCheck as any)?._isRecurringInstance
      
      // Firestore Ï†ÑÏö© Ï≤òÎ¶¨ (localStorage ÏÇ¨Ïö© Ï§ëÎã®)
      if (currentUser && !isRecurringTodo) {
        await firestoreService.updateTodo(id, updates, currentUser.uid)
        console.log('Firestore ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ:', id)
      } else if (isRecurringTodo) {
        // Î∞òÎ≥µ Ìï†ÏùºÏùÄ Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑúÎßå Í¥ÄÎ¶¨
        console.log('Î∞òÎ≥µ Ìï†Ïùº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏:', id)
        
        // Î∞òÎ≥µ Ìï†ÏùºÏùò order Í∞í ÏóÖÎç∞Ïù¥Ìä∏ÎèÑ ÏßÄÏõê
        if (updates.order !== undefined) {
          console.log('Î∞òÎ≥µ Ìï†Ïùº order ÏóÖÎç∞Ïù¥Ìä∏:', id, 'ÏÉà order:', updates.order)
          
          // Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏
          dispatch({
            type: 'UPDATE_RECURRING_INSTANCE',
            payload: {
              id: id,
              updates: { order: updates.order } // orderÎ•º Ïù∏Ïä§ÌÑ¥Ïä§Ïóê Ï∂îÍ∞Ä
            }
          })
        }
      } else {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î©îÎ™®Î¶¨ÏóêÏÑúÎßå Í¥ÄÎ¶¨
        console.log('ÎπÑÎ°úÍ∑∏Ïù∏ Î™®Îìú: Î©îÎ™®Î¶¨ÏóêÏÑú Ìï†Ïùº ÌÜ†Í∏Ä')
      }
      
      console.log(`Ìï†Ïùº ÌÜ†Í∏Ä ÏÑ±Í≥µ: ${id} (Î∞òÎ≥µÌï†Ïùº: ${isRecurringTodo})`)
    } catch (error: unknown) {
      console.error('Ìï†Ïùº ÌÜ†Í∏Ä Ïã§Ìå®:', error)
      // ÏóêÎü¨ Î∞úÏÉùÏãú Ïù¥Ï†Ñ ÏÉÅÌÉúÎ°ú ÎêòÎèåÎ¶º
      dispatch({ type: 'TOGGLE_TODO', payload: id })
      dispatch({ type: 'SET_ERROR', payload: 'Ìï†Ïùº ÏÉÅÌÉú Î≥ÄÍ≤Ω Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }

  // ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ Ï∂îÍ∞Ä
  const addSubTask = async (todoId: string, title: string) => {
    const newSubTask: SubTask = {
      id: generateId(),
      title,
      completed: false,
      priority: 'medium',
      createdAt: new Date(),
      updatedAt: new Date()
    }

    try {
      if (currentUser) {
        await firestoreService.addSubTask(newSubTask, currentUser.uid, todoId)
      } else {
        dispatch({ type: 'ADD_SUBTASK', payload: { todoId, subTask: newSubTask } })
        // Firestore Ï†ÑÏö© Î™®Îìú - localStorage ÏÇ¨Ïö© ÏïàÌï®
      }
    } catch (error) {
      console.error('ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ Ï∂îÍ∞Ä Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'ÌïòÏúÑ ÏûëÏóÖ Ï∂îÍ∞Ä Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }

  // ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ ÏóÖÎç∞Ïù¥Ìä∏
  const updateSubTask = async (todoId: string, subTaskId: string, updates: Partial<SubTask>) => {
    try {
      if (currentUser) {
        await firestoreService.updateSubTask(subTaskId, updates, currentUser.uid, todoId)
      } else {
        dispatch({ type: 'UPDATE_SUBTASK', payload: { todoId, subTaskId, updates } })
        // Firestore Ï†ÑÏö© Î™®Îìú - localStorage ÏÇ¨Ïö© ÏïàÌï®
      }
    } catch (error) {
      console.error('ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'ÌïòÏúÑ ÏûëÏóÖ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }

  // ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú
  const deleteSubTask = async (todoId: string, subTaskId: string) => {
    try {
      if (currentUser) {
        await firestoreService.deleteSubTask(subTaskId, currentUser.uid, todoId)
      } else {
        dispatch({ type: 'DELETE_SUBTASK', payload: { todoId, subTaskId } })
        // Firestore Ï†ÑÏö© Î™®Îìú - localStorage ÏÇ¨Ïö© ÏïàÌï®
      }
    } catch (error) {
      console.error('ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ ÏÇ≠Ï†ú Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'ÌïòÏúÑ ÏûëÏóÖ ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }

  // ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ ÌÜ†Í∏Ä
  const toggleSubTask = async (todoId: string, subTaskId: string) => {
    console.log('üîÑ ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ ÌÜ†Í∏Ä ÏãúÏûë:', { todoId, subTaskId })
    
    const todo = state.todos.find(t => t.id === todoId)
    const subTask = todo?.subTasks?.find(st => st.id === subTaskId)
    if (!subTask) {
      console.error('‚ùå ÏÑúÎ∏åÌÉúÏä§ÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå:', { todoId, subTaskId })
      return
    }

    const isCompleting = !subTask.completed
    console.log('üìä ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ ÏÉÅÌÉú:', { 
      ÌòÑÏû¨ÏôÑÎ£åÏÉÅÌÉú: subTask.completed,
      Î≥ÄÍ≤ΩÌõÑÏÉÅÌÉú: isCompleting,
      Í∏∞Ï°¥ÏôÑÎ£åÏãúÍ∞Ñ: subTask.completedAt
    })

    // deleteField() ÎåÄÏã† null ÏÇ¨Ïö©ÏúºÎ°ú Firestore Î∞∞Ïó¥ ÎÇ¥Î∂Ä Ïò§Î•ò Ìï¥Í≤∞
    const updates = {
      completed: isCompleting,
      completedAt: isCompleting ? new Date() : null as any
    }

    console.log('üìù ÏóÖÎç∞Ïù¥Ìä∏ Îç∞Ïù¥ÌÑ∞:', updates)

    await updateSubTask(todoId, subTaskId, updates)
  }

  // ÎÇ†ÏßúÎ≥Ñ Ìï†Ïùº ÌïÑÌÑ∞ÎßÅ Ìï®ÏàòÎì§ (Ï§ëÎ≥µ Î∞©ÏßÄ Í∞ïÌôî)
  const getTodayTodos = (targetDate?: Date) => {
    const today = targetDate ? new Date(targetDate) : new Date()
    today.setHours(0, 0, 0, 0) // ÏãúÍ∞Ñ Î∂ÄÎ∂ÑÏùÑ 00:00:00ÏúºÎ°ú ÏÑ§Ï†ï
    
    console.log('üóìÔ∏è getTodayTodos Ìò∏Ï∂úÎê®, ÎåÄÏÉÅ ÎÇ†Ïßú:', today.toDateString())
    
    const regularTodos = state.todos.filter(todo => {
      console.log(`üîç Ìï†Ïùº Ï≤¥ÌÅ¨: "${todo.title}"`)
      console.log(`  startDate: ${todo.startDate ? new Date(todo.startDate).toDateString() : 'null'}`)
      console.log(`  dueDate: ${todo.dueDate ? new Date(todo.dueDate).toDateString() : 'null'}`)
      console.log(`  completed: ${todo.completed}`)
      
      // ÏôÑÎ£åÎêú Ìï†ÏùºÏùò Í≤ΩÏö∞: Î©îÏù∏ Ìï†ÏùºÏù¥ Ïò§Îäò ÏôÑÎ£åÎêòÏóàÍ±∞ÎÇò, ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ Ï§ë Ïò§Îäò ÏôÑÎ£åÎêú Í≤ÉÏù¥ ÏûàÏúºÎ©¥ ÌëúÏãú
      if (todo.completed) {
        // Î©îÏù∏ Ìï†ÏùºÏù¥ Ïò§Îäò ÏôÑÎ£åÎêú Í≤ΩÏö∞
        if (todo.completedAt) {
          const completedDate = new Date(todo.completedAt)
          completedDate.setHours(0, 0, 0, 0)
          if (completedDate.getTime() === today.getTime()) {
            return true
          }
        }
        
        // ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ Ï§ë Ïò§Îäò ÏôÑÎ£åÎêú Í≤ÉÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        if (todo.subTasks && todo.subTasks.length > 0) {
          const hasSubTaskCompletedToday = todo.subTasks.some(subTask => {
            if (subTask.completed && subTask.completedAt && subTask.completedAt !== null) {
              try {
                const subTaskCompletedDate = new Date(subTask.completedAt)
                subTaskCompletedDate.setHours(0, 0, 0, 0)
                return subTaskCompletedDate.getTime() === today.getTime()
              } catch {
                return false
              }
            }
            return false
          })
          
          if (hasSubTaskCompletedToday) {
            console.log(`üìã "${todo.title}" - Ïò§Îäò ÏôÑÎ£åÎêú ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ ÏûàÏùå`)
            return true
          }
        }
        
        return false // Î©îÏù∏Ìï†ÏùºÎèÑ ÏÑúÎ∏åÌÉúÏä§ÌÅ¨ÎèÑ Ïò§Îäò ÏôÑÎ£åÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
      }
      
      // ÎØ∏ÏôÑÎ£å Ìï†ÏùºÏùò Í≤ΩÏö∞ - Í∏∞Í∞Ñ Í∏∞Î∞ò Î°úÏßÅ
      const startDate = todo.startDate ? new Date(todo.startDate) : null
      const dueDate = todo.dueDate ? new Date(todo.dueDate) : null
      
      if (startDate) startDate.setHours(0, 0, 0, 0)
      if (dueDate) dueDate.setHours(0, 0, 0, 0)
      
      console.log(`  Ï≤òÎ¶¨Îêú startDate: ${startDate ? startDate.toDateString() : 'null'}`)
      console.log(`  Ï≤òÎ¶¨Îêú dueDate: ${dueDate ? dueDate.toDateString() : 'null'}`)
      
      // 1. ÏãúÏûëÏùºÍ≥º ÎßàÍ∞êÏùºÏù¥ Î™®Îëê ÏûàÎäî Í≤ΩÏö∞: Í∏∞Í∞Ñ ÎÇ¥Ïóê Ìè¨Ìï®ÎêòÎäîÏßÄ ÌôïÏù∏
      if (startDate && dueDate) {
        const isInPeriod = today.getTime() >= startDate.getTime() && today.getTime() <= dueDate.getTime()
        console.log(`üìÖ Í∏∞Í∞Ñ Ìï†Ïùº Ï≤¥ÌÅ¨: "${todo.title}"`)
        console.log(`  ÏãúÏûëÏùº: ${startDate.toDateString()}, ÎßàÍ∞êÏùº: ${dueDate.toDateString()}`)
        console.log(`  Ïò§Îäò: ${today.toDateString()}, Í∏∞Í∞Ñ ÎÇ¥ Ìè¨Ìï®: ${isInPeriod}`)
        // ÎØ∏ÏôÑÎ£å Ìï†Ïùº: ÏãúÏûëÏùº~ÎßàÍ∞êÏùº Í∏∞Í∞Ñ ÎÇ¥ Î™®Îì† ÎÇ†ÏßúÏóê ÌëúÏãú
        return isInPeriod
      }
      
      // 2. ÏãúÏûëÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÏãúÏûëÏùº Ïù¥ÌõÑ Î™®Îì† ÎÇ†ÏßúÏóê ÌëúÏãú
      if (startDate && !dueDate) {
        return today.getTime() >= startDate.getTime()
      }
      
      // 3. ÎßàÍ∞êÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÎßàÍ∞êÏùºÍπåÏßÄ ÏßÄÏÜçÏ†ÅÏúºÎ°ú ÌëúÏãú
      if (!startDate && dueDate) {
        // ÎßàÍ∞êÏùºÏù¥ Ïò§ÎäòÏù¥Í±∞ÎÇò Ïù¥ÌõÑÏù∏ Í≤ΩÏö∞: ÏßÄÏÜçÏ†ÅÏúºÎ°ú ÌëúÏãú
        if (dueDate.getTime() >= today.getTime()) {
          console.log(`üìÖ ÎßàÍ∞êÏùº Ìï†Ïùº Ï≤¥ÌÅ¨: "${todo.title}" - ÎßàÍ∞êÏùºÍπåÏßÄ ÌëúÏãú`)
          console.log(`  ÎßàÍ∞êÏùº: ${dueDate.toDateString()}, Ïò§Îäò: ${today.toDateString()}`)
          return true
        }
        
        // ÎßàÍ∞êÏùºÏù¥ ÏßÄÎÇú Í≤ΩÏö∞: Ïñ¥Ï†ú Î™ªÌïú ÏùºÎ°úÎßå Ï≤òÎ¶¨ (Ïò§Îäò Ìï†ÏùºÏóêÎäî ÌëúÏãú ÏïàÌï®)
        console.log(`üìÖ ÎßàÍ∞êÏùº ÏßÄÎÇú Ìï†Ïùº: "${todo.title}" - Ïñ¥Ï†ú Ìï†ÏùºÎ°úÎßå ÌëúÏãú`)
        return false
      }
      
      // 3. ÎßàÍ∞êÏùºÎèÑ ÏãúÏûëÏùºÎèÑ ÏóÜÎäî ÎØ∏ÏôÑÎ£å Ìï†Ïùº (ÏùºÎ∞òÏ†ÅÏù∏ Ìï†Ïùº)
      if (!todo.dueDate && !todo.startDate) {
        return true
      }
      
      return false
    })

    // Î∞òÎ≥µ Ìï†Ïùº Ï∂îÍ∞Ä
    const todayRecurringList = getRecurringTodos()
    const filteredTodayRecurring = todayRecurringList.filter(todo => {
      if (todo.dueDate) {
        const dueDate = new Date(todo.dueDate)
        return dueDate.toDateString() === today.toDateString()
      }
      return false
    })

    // Ï§ëÎ≥µ Ï†úÍ±∞
    const seenIds = new Set<string>()
    const allTodos = [...regularTodos, ...filteredTodayRecurring]
    const uniqueTodos = allTodos.filter(todo => {
      if (seenIds.has(todo.id)) {
        console.warn(`‚ö†Ô∏è Ï§ëÎ≥µ ÌÇ§ Î∞úÍ≤¨ Î∞è Ï†úÍ±∞: ${todo.id}`)
        return false
      }
      seenIds.add(todo.id)
      return true
    })

    return uniqueTodos
  }

  const getWeekTodos = () => {
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    console.log('üìÖ getWeekTodos Ìò∏Ï∂úÎê®')
    
    // ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÎîîÎ≤ÑÍπÖ (Í∞ÑÎã®)
    const allRecurring = getRecurringTodos()
    const monthlyReports = allRecurring.filter(t => t.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†'))
    if (monthlyReports.length > 0) {
      console.log('üìÖ getWeekTodos - ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†:', monthlyReports[0]?.priority || 'none')
    }
    
    // Ïù¥Î≤à Ï£ºÏùò ÏãúÏûëÏùº (ÏùºÏöîÏùº)
    const startOfWeek = new Date(today)
    startOfWeek.setDate(today.getDate() - today.getDay())
    startOfWeek.setHours(0, 0, 0, 0)
    
    // Ïù¥Î≤à Ï£ºÏùò ÎßàÏßÄÎßâÏùº (ÌÜ†ÏöîÏùº)
    const endOfWeek = new Date(startOfWeek)
    endOfWeek.setDate(startOfWeek.getDate() + 6)
    endOfWeek.setHours(0, 0, 0, 0) // ÏãúÍ∞ÑÏùÑ 00:00:00ÏúºÎ°ú ÌÜµÏùº
    
    const regularTodos = state.todos.filter(todo => {
      
      // ÏôÑÎ£åÎêú Ìï†ÏùºÏùò Í≤ΩÏö∞: Ïù¥Î≤à Ï£ºÏóê ÏôÑÎ£åÎêú Í≤ÉÎßå ÌëúÏãú
      if (todo.completed && todo.completedAt) {
        const completedDate = new Date(todo.completedAt)
        completedDate.setHours(0, 0, 0, 0)
        return completedDate >= startOfWeek && completedDate <= endOfWeek
      }
      
      // ÎØ∏ÏôÑÎ£å Ìï†ÏùºÏùò Í≤ΩÏö∞ - Í∏∞Í∞Ñ Í∏∞Î∞ò Î°úÏßÅ
      if (!todo.completed) {
        const startDate = todo.startDate ? new Date(todo.startDate) : null
        const dueDate = todo.dueDate ? new Date(todo.dueDate) : null
        
        if (startDate) startDate.setHours(0, 0, 0, 0)
        if (dueDate) dueDate.setHours(0, 0, 0, 0)
        
        // 1. ÏãúÏûëÏùºÍ≥º ÎßàÍ∞êÏùºÏù¥ Î™®Îëê ÏûàÎäî Í≤ΩÏö∞: Í∏∞Í∞ÑÏù¥ Ïù¥Î≤à Ï£ºÏôÄ Í≤πÏπòÎäîÏßÄ ÌôïÏù∏
        if (startDate && dueDate) {
          // ÎØ∏ÏôÑÎ£å Ìï†Ïùº: Ìï†Ïùº Í∏∞Í∞ÑÍ≥º Ï£ºÍ∞Ñ Î≤îÏúÑÍ∞Ä Í≤πÏπòÎ©¥ ÌëúÏãú
          // Í≤πÏπ® Ï°∞Í±¥: Ìï†Ïùº ÎßàÍ∞êÏùº >= Ï£ºÍ∞Ñ ÏãúÏûëÏùº AND Ìï†Ïùº ÏãúÏûëÏùº <= Ï£ºÍ∞Ñ ÎßàÏßÄÎßâÏùº
          const overlapsWeek = dueDate.getTime() >= startOfWeek.getTime() && startDate.getTime() <= endOfWeek.getTime()
          return overlapsWeek
        }
        
        // 2. ÏãúÏûëÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÏãúÏûëÏùºÏù¥ Ïù¥Î≤à Ï£º Ïù¥Ï†ÑÏù¥Í±∞ÎÇò Ïù¥Î≤à Ï£ºÏóê ÏãúÏûë
        if (startDate && !dueDate) {
          return startDate <= endOfWeek
        }
        
        // 3. ÎßàÍ∞êÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÎßàÍ∞êÏùºÏù¥ Ïò§Îäò Ïù¥ÌõÑÏù¥Î©¥ ÌëúÏãú (getTodayTodosÏôÄ ÎèôÏùºÌïú Î°úÏßÅ)
        if (!startDate && dueDate) {
          // ÎßàÍ∞êÏùºÏù¥ Ïò§Îäò Ïù¥ÌõÑÏù¥Î©¥ ÌëúÏãú (ÎßàÍ∞êÏùºÍπåÏßÄ ÏßÄÏÜçÏ†ÅÏúºÎ°ú)
          return dueDate >= today
        }
        
        // 4. ÎÇ†ÏßúÍ∞Ä ÏóÜÎäî ÏùºÎ∞ò Ìï†Ïùº - Ïò§Îäò Ìï†ÏùºÍ≥º ÎèôÏùºÌïòÍ≤å ÌëúÏãú
        if (!startDate && !dueDate) {
          return true
        }
      }
      
      return false
    })

    // Î∞òÎ≥µ Ìï†Ïùº Ï∂îÍ∞Ä - Í∏∞Í∞Ñ Í∏∞Î∞ò Î°úÏßÅ Ï†ÅÏö©
    const weeklyRecurringTodos = getRecurringTodos()
    const weekRecurringTodos = weeklyRecurringTodos.filter(todo => {
      // ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÌäπÎ≥Ñ ÎîîÎ≤ÑÍπÖ
      if (todo.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')) {
        console.log(`üîç Ï£ºÍ∞ÑÎ∑∞ - ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÌïÑÌÑ∞ÎßÅ: completed=${todo.completed}, completedAt=${todo.completedAt}`)
      }
      
      // ‚úÖ ÏôÑÎ£åÎêú Î∞òÎ≥µ Ìï†Ïùº: Ïù¥Î≤à Ï£ºÏóê ÏôÑÎ£åÎêú Í≤ÉÎßå ÌëúÏãú 
      if (todo.completed) {
        if (todo.completedAt) {
          const completedDate = new Date(todo.completedAt)
          completedDate.setHours(0, 0, 0, 0)
          const isInThisWeek = completedDate >= startOfWeek && completedDate <= endOfWeek
          
          if (todo.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')) {
            console.log(`   ‚úÖ ÏôÑÎ£åÎêú ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†: ÏôÑÎ£åÏùº=${completedDate.toDateString()}, Ïù¥Î≤àÏ£ºÌè¨Ìï®=${isInThisWeek}`)
          }
          
          return isInThisWeek
        }
        
        if (todo.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')) {
          console.log(`   ‚ùå ÏôÑÎ£åÎêú ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†: ÏôÑÎ£åÏùº ÏóÜÏùå - ÌëúÏãú ÏïàÌï®`)
        }
        
        return false // ÏôÑÎ£åÎêòÏóàÏßÄÎßå ÏôÑÎ£åÏùºÏù¥ ÏóÜÏúºÎ©¥ ÌëúÏãú ÏïàÌï®
      }
      
      // üî• ÎØ∏ÏôÑÎ£å Î∞òÎ≥µ Ìï†ÏùºÎßå Ï≤òÎ¶¨ - Í∏∞Í∞Ñ Í∏∞Î∞ò Î°úÏßÅ
      // (ÏôÑÎ£åÎêú Ìï†ÏùºÏùÄ ÏúÑÏóêÏÑú Ïù¥ÎØ∏ Ï≤òÎ¶¨ÌïòÏó¨ Ïó¨Í∏∞ ÎèÑÎã¨ÌïòÏßÄ ÏïäÏùå)
      const startDate = todo.startDate ? new Date(todo.startDate) : null
      const dueDate = todo.dueDate ? new Date(todo.dueDate) : null
      
      if (startDate) startDate.setHours(0, 0, 0, 0)
      if (dueDate) dueDate.setHours(0, 0, 0, 0)
      
      // 1. ÏãúÏûëÏùºÍ≥º ÎßàÍ∞êÏùºÏù¥ Î™®Îëê ÏûàÎäî Í≤ΩÏö∞: Í∏∞Í∞ÑÏù¥ Ïù¥Î≤à Ï£ºÏôÄ Í≤πÏπòÎäîÏßÄ ÌôïÏù∏
      if (startDate && dueDate) {
        // Î∞òÎ≥µ Ìï†Ïùº: Ìï†Ïùº Í∏∞Í∞ÑÍ≥º Ï£ºÍ∞Ñ Î≤îÏúÑÍ∞Ä Í≤πÏπòÎ©¥ ÌëúÏãú
        const overlapsWeek = dueDate.getTime() >= startOfWeek.getTime() && startDate.getTime() <= endOfWeek.getTime()
        console.log(`üîÑ Ï£ºÍ∞Ñ Î∞òÎ≥µ Í∏∞Í∞Ñ Ìï†Ïùº Ï≤¥ÌÅ¨: "${todo.title}"`)
        console.log(`  Ìï†Ïùº Í∏∞Í∞Ñ: ${startDate.toDateString()} ~ ${dueDate.toDateString()}`)
        console.log(`  Ï£ºÍ∞Ñ Î≤îÏúÑ: ${startOfWeek.toDateString()} ~ ${endOfWeek.toDateString()}`)
        console.log(`  Í≤πÏπ® Ïó¨Î∂Ä: ${overlapsWeek}`)
        return overlapsWeek
      }
      
      // 2. ÏãúÏûëÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÏãúÏûëÏùºÏù¥ Ïù¥Î≤à Ï£º Ïù¥Ï†ÑÏù¥Í±∞ÎÇò Ïù¥Î≤à Ï£ºÏóê ÏãúÏûë
      if (startDate && !dueDate) {
        return startDate <= endOfWeek
      }
      
      // 3. ÎßàÍ∞êÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÎßàÍ∞êÏùºÏù¥ Ïù¥Î≤à Ï£º ÏãúÏûëÏùº Ïù¥ÌõÑÎ©¥ ÏßÄÏÜçÏ†ÅÏúºÎ°ú ÌëúÏãú
      if (!startDate && dueDate) {
        // ÎßàÍ∞êÏùºÏù¥ Ïù¥Î≤à Ï£º ÏãúÏûëÏùº Ïù¥ÌõÑÎ©¥ ÌëúÏãú (ÎßàÍ∞êÏùºÍπåÏßÄ ÏßÄÏÜçÏ†ÅÏúºÎ°ú)
        return dueDate >= startOfWeek
      }
      
      // 4. ÎÇ†ÏßúÍ∞Ä ÏóÜÎäî Î∞òÎ≥µ Ìï†Ïùº
      if (!startDate && !dueDate) {
        return true
      }
      
      return false
    })

    const allWeekTodos = [...regularTodos, ...weekRecurringTodos]
    
    // üî• Ïò§Îäò Ìï†ÏùºÍ≥º ÎèôÏùºÌïú Ï†ïÎ†¨ Ï†ÅÏö©
    console.log('üìä getWeekTodos Ï†ïÎ†¨ Ï†Ñ ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† Í∞úÏàò:', allWeekTodos.filter(t => t.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')).length)
    
    // Ïö∞ÏÑ†ÏàúÏúÑÎ≥Ñ Ï†ïÎ†¨ (urgent ‚Üí high ‚Üí medium ‚Üí low)
    const priorityOrder = { urgent: 0, high: 1, medium: 2, low: 3 }
    const sortedWeekTodos = allWeekTodos.sort((a, b) => {
      const priorityDiff = priorityOrder[a.priority as keyof typeof priorityOrder] - priorityOrder[b.priority as keyof typeof priorityOrder]
      if (priorityDiff !== 0) {
        return priorityDiff
      }
      // Í∞ôÏùÄ Ïö∞ÏÑ†ÏàúÏúÑÎ©¥ order ‚Üí ÎÇ†ÏßúÏàú Ï†ïÎ†¨
      const orderA = a.order || 0
      const orderB = b.order || 0
      if (orderA !== orderB) {
        return orderA - orderB
      }
      return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
    })
    
    console.log('üìä getWeekTodos Ï†ïÎ†¨ ÌõÑ ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†:', sortedWeekTodos.filter(t => t.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')).map(t => `${t.title}: ${t.priority}`))
    
    return sortedWeekTodos
  }

  const getMonthTodos = () => {
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    console.log('üìÜ getMonthTodos Ìò∏Ï∂úÎê®')
    
    // Ïù¥Î≤à Îã¨Ïùò ÏãúÏûëÏùº (1Ïùº)
    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1)
    startOfMonth.setHours(0, 0, 0, 0)
    
    // Ïù¥Î≤à Îã¨Ïùò ÎßàÏßÄÎßâÏùº (ÎßêÏùº)
    const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0)
    endOfMonth.setHours(0, 0, 0, 0) // ÏãúÍ∞ÑÏùÑ 00:00:00ÏúºÎ°ú ÌÜµÏùº
    
    const regularTodos = state.todos.filter(todo => {
      
      // ÏôÑÎ£åÎêú Ìï†ÏùºÏùò Í≤ΩÏö∞: Ïù¥Î≤à Îã¨Ïóê ÏôÑÎ£åÎêú Í≤ÉÎßå ÌëúÏãú
      if (todo.completed && todo.completedAt) {
        const completedDate = new Date(todo.completedAt)
        completedDate.setHours(0, 0, 0, 0)
        return completedDate >= startOfMonth && completedDate <= endOfMonth
      }
      
      // ÎØ∏ÏôÑÎ£å Ìï†ÏùºÏùò Í≤ΩÏö∞ - Í∏∞Í∞Ñ Í∏∞Î∞ò Î°úÏßÅ
      if (!todo.completed) {
        const startDate = todo.startDate ? new Date(todo.startDate) : null
        const dueDate = todo.dueDate ? new Date(todo.dueDate) : null
        
        if (startDate) startDate.setHours(0, 0, 0, 0)
        if (dueDate) dueDate.setHours(0, 0, 0, 0)
        
        // 1. ÏãúÏûëÏùºÍ≥º ÎßàÍ∞êÏùºÏù¥ Î™®Îëê ÏûàÎäî Í≤ΩÏö∞: Í∏∞Í∞ÑÏù¥ Ïù¥Î≤à Îã¨Í≥º Í≤πÏπòÎäîÏßÄ ÌôïÏù∏
        if (startDate && dueDate) {
          // ÎØ∏ÏôÑÎ£å Ìï†Ïùº: Ìï†Ïùº Í∏∞Í∞ÑÍ≥º ÏõîÍ∞Ñ Î≤îÏúÑÍ∞Ä Í≤πÏπòÎ©¥ ÌëúÏãú
          // Í≤πÏπ® Ï°∞Í±¥: Ìï†Ïùº ÎßàÍ∞êÏùº >= ÏõîÍ∞Ñ ÏãúÏûëÏùº AND Ìï†Ïùº ÏãúÏûëÏùº <= ÏõîÍ∞Ñ ÎßàÏßÄÎßâÏùº
          const overlapsMonth = dueDate.getTime() >= startOfMonth.getTime() && startDate.getTime() <= endOfMonth.getTime()
          return overlapsMonth
        }
        
        // 2. ÏãúÏûëÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÏãúÏûëÏùºÏù¥ Ïù¥Î≤à Îã¨ Ïù¥Ï†ÑÏù¥Í±∞ÎÇò Ïù¥Î≤à Îã¨Ïóê ÏãúÏûë
        if (startDate && !dueDate) {
          return startDate <= endOfMonth
        }
        
        // 3. ÎßàÍ∞êÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÎßàÍ∞êÏùºÏù¥ Ïò§Îäò Ïù¥ÌõÑÏù¥Î©¥ ÌëúÏãú (getTodayTodosÏôÄ ÎèôÏùºÌïú Î°úÏßÅ)
        if (!startDate && dueDate) {
          // ÎßàÍ∞êÏùºÏù¥ Ïò§Îäò Ïù¥ÌõÑÏù¥Î©¥ ÌëúÏãú (ÎßàÍ∞êÏùºÍπåÏßÄ ÏßÄÏÜçÏ†ÅÏúºÎ°ú)
          return dueDate >= today
        }
        
        // 4. ÎÇ†ÏßúÍ∞Ä ÏóÜÎäî ÏùºÎ∞ò Ìï†Ïùº - Ïò§Îäò Ìï†ÏùºÍ≥º ÎèôÏùºÌïòÍ≤å ÌëúÏãú
        if (!startDate && !dueDate) {
          return true
        }
      }
      
      return false
    })

    // Î∞òÎ≥µ Ìï†Ïùº Ï∂îÍ∞Ä - Í∏∞Í∞Ñ Í∏∞Î∞ò Î°úÏßÅ Ï†ÅÏö©
    const monthlyRecurringTodos = getRecurringTodos()
    const monthRecurringTodos = monthlyRecurringTodos.filter(todo => {
      // ‚úÖ ÏôÑÎ£åÎêú Î∞òÎ≥µ Ìï†Ïùº: Ïù¥Î≤à Îã¨Ïóê ÏôÑÎ£åÎêú Í≤ÉÎßå ÌëúÏãú
      if (todo.completed) {
        if (todo.completedAt) {
          const completedDate = new Date(todo.completedAt)
          completedDate.setHours(0, 0, 0, 0)
          return completedDate >= startOfMonth && completedDate <= endOfMonth
        }
        return false // ÏôÑÎ£åÎêòÏóàÏßÄÎßå ÏôÑÎ£åÏùºÏù¥ ÏóÜÏúºÎ©¥ ÌëúÏãú ÏïàÌï®
      }
      
        // üî• ÎØ∏ÏôÑÎ£å Î∞òÎ≥µ Ìï†ÏùºÎßå Ï≤òÎ¶¨ - Í∏∞Í∞Ñ Í∏∞Î∞ò Î°úÏßÅ
      // (ÏôÑÎ£åÎêú Ìï†ÏùºÏùÄ ÏúÑÏóêÏÑú Ïù¥ÎØ∏ Ï≤òÎ¶¨ÌïòÏó¨ Ïó¨Í∏∞ ÎèÑÎã¨ÌïòÏßÄ ÏïäÏùå)
      const startDate = todo.startDate ? new Date(todo.startDate) : null
      const dueDate = todo.dueDate ? new Date(todo.dueDate) : null
      
      if (startDate) startDate.setHours(0, 0, 0, 0)
      if (dueDate) dueDate.setHours(0, 0, 0, 0)
      
      // 1. ÏãúÏûëÏùºÍ≥º ÎßàÍ∞êÏùºÏù¥ Î™®Îëê ÏûàÎäî Í≤ΩÏö∞: Í∏∞Í∞ÑÏù¥ Ïù¥Î≤à Îã¨Í≥º Í≤πÏπòÎäîÏßÄ ÌôïÏù∏
      if (startDate && dueDate) {
        // Î∞òÎ≥µ Ìï†Ïùº: Ìï†Ïùº Í∏∞Í∞ÑÍ≥º ÏõîÍ∞Ñ Î≤îÏúÑÍ∞Ä Í≤πÏπòÎ©¥ ÌëúÏãú
        const overlapsMonth = dueDate.getTime() >= startOfMonth.getTime() && startDate.getTime() <= endOfMonth.getTime()
        console.log(`üîÑ ÏõîÍ∞Ñ Î∞òÎ≥µ Í∏∞Í∞Ñ Ìï†Ïùº Ï≤¥ÌÅ¨: "${todo.title}"`)
        console.log(`  Ìï†Ïùº Í∏∞Í∞Ñ: ${startDate.toDateString()} ~ ${dueDate.toDateString()}`)
        console.log(`  ÏõîÍ∞Ñ Î≤îÏúÑ: ${startOfMonth.toDateString()} ~ ${endOfMonth.toDateString()}`)
        console.log(`  Í≤πÏπ® Ïó¨Î∂Ä: ${overlapsMonth}`)
        return overlapsMonth
      }
      
      // 2. ÏãúÏûëÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÏãúÏûëÏùºÏù¥ Ïù¥Î≤à Îã¨ Ïù¥Ï†ÑÏù¥Í±∞ÎÇò Ïù¥Î≤à Îã¨Ïóê ÏãúÏûë
      if (startDate && !dueDate) {
        return startDate <= endOfMonth
      }
      
      // 3. ÎßàÍ∞êÏùºÎßå ÏûàÎäî Í≤ΩÏö∞: ÎßàÍ∞êÏùºÏù¥ Ïù¥Î≤à Îã¨ ÏãúÏûëÏùº Ïù¥ÌõÑÎ©¥ ÏßÄÏÜçÏ†ÅÏúºÎ°ú ÌëúÏãú
      if (!startDate && dueDate) {
        // ÎßàÍ∞êÏùºÏù¥ Ïù¥Î≤à Îã¨ ÏãúÏûëÏùº Ïù¥ÌõÑÎ©¥ ÌëúÏãú (ÎßàÍ∞êÏùºÍπåÏßÄ ÏßÄÏÜçÏ†ÅÏúºÎ°ú)
        return dueDate >= startOfMonth
      }
      
      // 4. ÎÇ†ÏßúÍ∞Ä ÏóÜÎäî Î∞òÎ≥µ Ìï†Ïùº
      if (!startDate && !dueDate) {
        return true
      }
      
      return false
    })

    const allMonthTodos = [...regularTodos, ...monthRecurringTodos]
    
    // üî• Ïò§Îäò Ìï†ÏùºÍ≥º ÎèôÏùºÌïú Ï†ïÎ†¨ Ï†ÅÏö©
    console.log('üìä getMonthTodos Ï†ïÎ†¨ Ï†Ñ ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† Í∞úÏàò:', allMonthTodos.filter(t => t.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')).length)
    
    // Ïö∞ÏÑ†ÏàúÏúÑÎ≥Ñ Ï†ïÎ†¨ (urgent ‚Üí high ‚Üí medium ‚Üí low)
    const priorityOrder = { urgent: 0, high: 1, medium: 2, low: 3 }
    const sortedMonthTodos = allMonthTodos.sort((a, b) => {
      const priorityDiff = priorityOrder[a.priority as keyof typeof priorityOrder] - priorityOrder[b.priority as keyof typeof priorityOrder]
      if (priorityDiff !== 0) {
        return priorityDiff
      }
      // Í∞ôÏùÄ Ïö∞ÏÑ†ÏàúÏúÑÎ©¥ order ‚Üí ÎÇ†ÏßúÏàú Ï†ïÎ†¨
      const orderA = a.order || 0
      const orderB = b.order || 0
      if (orderA !== orderB) {
        return orderA - orderB
      }
      return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
    })
    
    console.log('üìä getMonthTodos Ï†ïÎ†¨ ÌõÑ ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†:', sortedMonthTodos.filter(t => t.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')).map(t => `${t.title}: ${t.priority}`))
    
    return sortedMonthTodos
  }

  const getOverdueTodos = () => {
    const today = new Date()
    today.setHours(0, 0, 0, 0)

    return state.todos.filter(todo => {
      if (!todo.dueDate || todo.completed) return false
      const dueDate = new Date(todo.dueDate)
      dueDate.setHours(0, 0, 0, 0)
      return dueDate < today
    })
  }

  const getTomorrowTodos = (targetDate?: Date) => {
    const baseDate = targetDate || new Date()
    const tomorrow = new Date(baseDate)
    tomorrow.setDate(tomorrow.getDate() + 1)
    
    return state.todos.filter(todo => {
      if (!todo.dueDate) return false
      const dueDate = new Date(todo.dueDate)
      return dueDate.toDateString() === tomorrow.toDateString()
    })
  }

  const getYesterdayIncompleteTodos = (targetDate?: Date) => {
    const baseDate = targetDate || new Date()
    const today = new Date(baseDate)
    today.setHours(0, 0, 0, 0)
    
    return state.todos.filter(todo => {
      if (todo.completed || !todo.dueDate) return false
      const dueDate = new Date(todo.dueDate)
      dueDate.setHours(0, 0, 0, 0)
      
      // ÎßàÍ∞êÏùºÏù¥ Ïò§ÎäòÎ≥¥Îã§ Ïù¥Ï†ÑÏù∏ ÎØ∏ÏôÑÎ£å Ìï†ÏùºÎì§ÏùÑ Ïñ¥Ï†ú Ìï†ÏùºÎ°ú Ï≤òÎ¶¨
      return dueDate.getTime() < today.getTime()
    })
  }

  const isYesterdayIncompleteTodo = (todo: Todo) => {
    if (todo.completed || !todo.dueDate) return false
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const dueDate = new Date(todo.dueDate)
    dueDate.setHours(0, 0, 0, 0)
    
    // ÎßàÍ∞êÏùºÏù¥ Ïò§ÎäòÎ≥¥Îã§ Ïù¥Ï†ÑÏù∏ ÎØ∏ÏôÑÎ£å Ìï†ÏùºÎì§ÏùÑ Ïñ¥Ï†ú Ìï†ÏùºÎ°ú Ï≤òÎ¶¨
    return dueDate.getTime() < today.getTime()
  }

  const updateTodoOrder = async (todoId: string, newOrder: number) => {
    // Î∞òÎ≥µ Ìï†ÏùºÏù∏ÏßÄ ÌôïÏù∏
    const isRecurringTodo = todoId.startsWith('recurring_')
    
    if (isRecurringTodo) {
      // Î∞òÎ≥µ Ìï†ÏùºÏùò Í≤ΩÏö∞: instanceId Ï∂îÏ∂úÌïòÍ≥† UPDATE_RECURRING_INSTANCE ÏÇ¨Ïö©
      const instanceId = todoId.replace('recurring_', '')
      
      dispatch({
        type: 'UPDATE_RECURRING_INSTANCE',
        payload: {
          id: instanceId,
          updates: { order: newOrder }
        }
      })
      
      debug.log('Î∞òÎ≥µ Ìï†Ïùº ÏàúÏÑú ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ', { todoId, instanceId, newOrder })
    } else {
      // ÏùºÎ∞ò Ìï†ÏùºÏùò Í≤ΩÏö∞: Í∏∞Ï°¥ Î°úÏßÅ ÏÇ¨Ïö©
      dispatch({
        type: 'UPDATE_TODO',
        payload: {
          id: todoId,
          updates: { order: newOrder, updatedAt: new Date() }
        }
      })

      // FirestoreÏóêÎèÑ Ï†ÄÏû• (Ïù∏Ï¶ùÎêú ÏÇ¨Ïö©ÏûêÎßå)
      if (currentUser?.uid) {
        try {
          await firestoreService.updateTodo(todoId, { order: newOrder }, currentUser.uid)
          debug.log('Ìï†Ïùº ÏàúÏÑú Firestore Ï†ÄÏû• ÏÑ±Í≥µ', { todoId, newOrder })
        } catch (error) {
          debug.error('Ìï†Ïùº ÏàúÏÑú Firestore Ï†ÄÏû• Ïã§Ìå®:', error)
          // ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥ÎèÑ Î°úÏª¨ stateÎäî Ïú†ÏßÄ
        }
      }
    }
  }

  const reorderTodos = async (sourceIndex: number, destinationIndex: number, todos: Todo[]) => {
    const reorderedTodos = Array.from(todos)
    const [removed] = reorderedTodos.splice(sourceIndex, 1)
    reorderedTodos.splice(destinationIndex, 0, removed)

    // ÏÉàÎ°úÏö¥ ÏàúÏÑúÎ°ú order Í∞í ÏóÖÎç∞Ïù¥Ìä∏ (Î≥ëÎ†¨ Ï≤òÎ¶¨)
    const updatePromises = reorderedTodos.map((todo, index) => 
      updateTodoOrder(todo.id, index)
    )
    
    try {
      await Promise.all(updatePromises)
      debug.log('Î™®Îì† Ìï†Ïùº ÏàúÏÑú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å', { count: updatePromises.length })
    } catch (error) {
      debug.error('Ìï†Ïùº ÏàúÏÑú ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë ÏùºÎ∂Ä Ïã§Ìå®:', error)
    }
  }

  const getFilteredTodos = (filters: {
    searchTerm?: string
    priorityFilter?: Priority | 'all'
    typeFilter?: TaskType | 'all'
    projectFilter?: 'all' | 'longterm' | 'shortterm'
    tagFilter?: string[]
    completionDateFilter?: 'all' | 'today' | 'yesterday' | 'thisWeek' | 'lastWeek' | 'thisMonth'
    includeCompleted?: boolean
  }) => {
    // ÏùºÎ∞ò Ìï†ÏùºÍ≥º Î∞òÎ≥µ Ìï†ÏùºÏùÑ Î™®Îëê Ìè¨Ìï®
    const allTodos = [...state.todos, ...getRecurringTodos()]
    
    return allTodos.filter(todo => {
      // Í≤ÄÏÉâÏñ¥ ÌïÑÌÑ∞
      if (filters.searchTerm) {
        const searchLower = filters.searchTerm.toLowerCase()
        const matchesTitle = todo.title.toLowerCase().includes(searchLower)
        const matchesDescription = todo.description?.toLowerCase().includes(searchLower) || false
        const matchesTags = todo.tags?.some(tag => tag.toLowerCase().includes(searchLower)) || false
        
        if (!matchesTitle && !matchesDescription && !matchesTags) {
          return false
        }
      }

      // Ïö∞ÏÑ†ÏàúÏúÑ ÌïÑÌÑ∞
      if (filters.priorityFilter && filters.priorityFilter !== 'all') {
        if (todo.priority !== filters.priorityFilter) return false
      }

      // ÌÉÄÏûÖ ÌïÑÌÑ∞
      if (filters.typeFilter && filters.typeFilter !== 'all') {
        if (todo.type !== filters.typeFilter) return false
      }

      // ÌîÑÎ°úÏ†ùÌä∏ ÌïÑÌÑ∞
      if (filters.projectFilter && filters.projectFilter !== 'all') {
        if (todo.project !== filters.projectFilter) return false
      }

      // ÌÉúÍ∑∏ ÌïÑÌÑ∞
      if (filters.tagFilter && filters.tagFilter.length > 0) {
        const todoTags = todo.tags || []
        const hasMatchingTag = filters.tagFilter.some(filterTag => 
          todoTags.includes(filterTag)
        )
        if (!hasMatchingTag) return false
      }

      // ÏôÑÎ£åÏùº ÌïÑÌÑ∞
      if (filters.completionDateFilter && filters.completionDateFilter !== 'all' && todo.completedAt) {
        const completedDate = new Date(todo.completedAt)
        const today = new Date()
        
        switch (filters.completionDateFilter) {
          case 'today':
            if (completedDate.toDateString() !== today.toDateString()) return false
            break
          case 'yesterday':
            const yesterday = new Date()
            yesterday.setDate(today.getDate() - 1)
            if (completedDate.toDateString() !== yesterday.toDateString()) return false
            break
          case 'thisWeek':
            const startOfWeek = new Date(today)
            startOfWeek.setDate(today.getDate() - today.getDay())
            startOfWeek.setHours(0, 0, 0, 0)
            if (completedDate < startOfWeek) return false
            break
          case 'lastWeek':
            const startOfLastWeek = new Date(today)
            startOfLastWeek.setDate(today.getDate() - today.getDay() - 7)
            startOfLastWeek.setHours(0, 0, 0, 0)
            const endOfLastWeek = new Date(today)
            endOfLastWeek.setDate(today.getDate() - today.getDay() - 1)
            endOfLastWeek.setHours(23, 59, 59, 999)
            if (completedDate < startOfLastWeek || completedDate > endOfLastWeek) return false
            break
          case 'thisMonth':
            const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1)
            if (completedDate < startOfMonth) return false
            break
        }
      }

      // ÏôÑÎ£å ÏÉÅÌÉú ÌïÑÌÑ∞
      if (filters.includeCompleted === false && todo.completed) {
        return false
      }

      return true
    })
  }

  // Î∞òÎ≥µ Ìï†Ïùº Í¥ÄÎ†® Ìï®ÏàòÎì§
  const addRecurringTemplate = async (templateData: Omit<SimpleRecurringTemplate, 'id' | 'createdAt' | 'updatedAt'>) => {
    console.log('=== Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Ï∂îÍ∞Ä ÏãúÏûë ===')
    console.log('currentUser:', currentUser)
    console.log('templateData:', templateData)
    
    try {
      if (currentUser) {
        // Firestore Ï†ÑÏö© Ï†ÄÏû•
        console.log('Firestore Î™®ÎìúÎ°ú Ï†ÄÏû• ÏãúÎèÑ')
        const firestoreId = await firestoreService.addRecurringTemplate(templateData, currentUser.uid)
        console.log('Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Firestore Ï†ÄÏû• ÏÑ±Í≥µ:', firestoreId)
        
        // üî• Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±ÏùÄ useEffectÏóêÏÑú ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê® (Ï§ëÎ≥µ Î∞©ÏßÄ)
        console.log('‚úÖ ÌÖúÌîåÎ¶ø Ï†ÄÏû• ÏôÑÎ£å - Ïù∏Ïä§ÌÑ¥Ïä§Îäî useEffectÏóêÏÑú ÏûêÎèô ÏÉùÏÑ±Îê®')
      } else {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î©îÎ™®Î¶¨Ïóê Ï†ÄÏû• ÌõÑ localStorageÏóê ÏûêÎèô Ï†ÄÏû•
        console.log('ÎπÑÎ°úÍ∑∏Ïù∏ Î™®Îìú: Î©îÎ™®Î¶¨Ïóê Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Ï∂îÍ∞Ä')
        const newTemplate: SimpleRecurringTemplate = {
          ...templateData,
          id: generateId(),
          createdAt: new Date(),
          updatedAt: new Date()
        }
        dispatch({ type: 'ADD_RECURRING_TEMPLATE', payload: newTemplate })
        // localStorage Ï†ÄÏû•ÏùÄ useEffectÏóêÏÑú ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê®
      }
      console.log('=== Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Ï∂îÍ∞Ä ÏôÑÎ£å ===')
    } catch (error) {
      console.error('Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Ï∂îÍ∞Ä Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'Î∞òÎ≥µ Ìï†Ïùº Ï∂îÍ∞Ä Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }

  const updateRecurringTemplate = async (id: string, updates: Partial<SimpleRecurringTemplate>) => {
    console.log('üîß Î∞òÎ≥µ ÌÖúÌîåÎ¶ø ÏàòÏ†ï ÏãúÏûë')
    console.log('ÌÖúÌîåÎ¶ø ID:', id)
    console.log('ÏàòÏ†ï Îç∞Ïù¥ÌÑ∞:', updates)

    try {
      if (currentUser) {
        console.log('üî• Firebase ÏÇ¨Ïö©Ïûê - ÌÖúÌîåÎ¶øÎßå ÏóÖÎç∞Ïù¥Ìä∏ (Ïù∏Ïä§ÌÑ¥Ïä§Îäî useEffectÏóêÏÑú ÏûêÎèô Ï≤òÎ¶¨)')

        // 1. Firestore ÌÖúÌîåÎ¶ø ÏóÖÎç∞Ïù¥Ìä∏ (Ïù∏Ïä§ÌÑ¥Ïä§ Ïû¨ÏÉùÏÑ±ÏùÄ ÌïòÏßÄ ÏïäÏùå)
        console.log('1Ô∏è‚É£ Firestore ÌÖúÌîåÎ¶ø ÏóÖÎç∞Ïù¥Ìä∏Îßå ÏàòÌñâ')
        await firestoreService.updateRecurringTemplate(id, updates, currentUser.uid)
        console.log('‚úÖ Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Firestore ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å:', id)

        // 2. Î°úÏª¨ ÏÉÅÌÉú ÌÖúÌîåÎ¶ø ÏóÖÎç∞Ïù¥Ìä∏
        console.log('2Ô∏è‚É£ Î°úÏª¨ ÏÉÅÌÉú ÌÖúÌîåÎ¶ø ÏóÖÎç∞Ïù¥Ìä∏')
        dispatch({ type: 'UPDATE_RECURRING_TEMPLATE', payload: { id, updates } })
        console.log('‚úÖ Î°úÏª¨ ÏÉÅÌÉú ÌÖúÌîåÎ¶ø ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å')

        // üìù NOTE: Ïù∏Ïä§ÌÑ¥Ïä§ Ïû¨ÏÉùÏÑ±ÏùÄ useEffectÏóêÏÑú ÌÖúÌîåÎ¶ø Î≥ÄÍ≤ΩÏùÑ Í∞êÏßÄÌïòÏó¨ ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê©ÎãàÎã§.
        console.log('üí° Ïù∏Ïä§ÌÑ¥Ïä§ Ïû¨ÏÉùÏÑ±ÏùÄ useEffectÏóêÏÑú ÏûêÎèô Ï≤òÎ¶¨Îê©ÎãàÎã§.')
        
      } else {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î©îÎ™®Î¶¨ÏóêÏÑú ÏóÖÎç∞Ïù¥Ìä∏
        console.log('ÎπÑÎ°úÍ∑∏Ïù∏ Î™®Îìú: Î©îÎ™®Î¶¨ÏóêÏÑú Î∞òÎ≥µ ÌÖúÌîåÎ¶ø ÏóÖÎç∞Ïù¥Ìä∏')
        
        // 1. Í∏∞Ï°¥ Ìï†Ïùº Ï§ë Ìï¥Îãπ ÌÖúÌîåÎ¶øÏóêÏÑú ÏÉùÏÑ±Îêú Í≤ÉÎì§ ÏÇ≠Ï†ú
        const todosToRemove = state.todos.filter((todo: any) => todo._templateId === id)
        console.log(`ÌÖúÌîåÎ¶ø ${id}ÏóêÏÑú ÏÉùÏÑ±Îêú Ìï†Ïùº ${todosToRemove.length}Í∞ú Î∞úÍ≤¨`)
        
        for (const todo of todosToRemove) {
          console.log(`Ìï†Ïùº ÏÇ≠Ï†ú: ${todo.title} (${todo.id})`)
          dispatch({ type: 'DELETE_TODO', payload: todo.id })
        }
        
        // 2. ÌÖúÌîåÎ¶ø ÏóÖÎç∞Ïù¥Ìä∏
        dispatch({ type: 'UPDATE_RECURRING_TEMPLATE', payload: { id, updates } })
        
        // 3. ÏÉàÎ°úÏö¥ Ìï†ÏùºÎì§ ÏÉùÏÑ±
        setTimeout(() => {
          console.log('ÏóÖÎç∞Ïù¥Ìä∏Îêú ÌÖúÌîåÎ¶øÏúºÎ°ú ÏÉàÎ°úÏö¥ Ìï†Ïùº ÏÉùÏÑ± ÏãúÏûë')
          generateRecurringInstances()
        }, 100)
      }
      console.log('=== Î∞òÎ≥µ ÌÖúÌîåÎ¶ø ÏàòÏ†ï ÏôÑÎ£å ===')
    } catch (error) {
      console.error('Î∞òÎ≥µ ÌÖúÌîåÎ¶ø ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'Î∞òÎ≥µ Ìï†Ïùº ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }

  // Ï§ëÎ≥µÎêú Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Ï†ïÎ¶¨ Ìï®Ïàò
  const cleanupDuplicateTemplates = () => {
    console.log('üßπ Ï§ëÎ≥µ Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Ï†ïÎ¶¨ ÏãúÏûë')
    
    const titleGroups: { [title: string]: any[] } = {}
    state.recurringTemplates.forEach(template => {
      const title = template.title
      if (!titleGroups[title]) {
        titleGroups[title] = []
      }
      titleGroups[title].push(template)
    })
    
    const duplicates = Object.entries(titleGroups).filter(([title, items]) => items.length > 1)
    
    if (duplicates.length > 0) {
      console.log('‚ùå Ï§ëÎ≥µÎêú ÌÖúÌîåÎ¶øÎì§:', duplicates.map(([title, items]) => `${title}: ${items.length}Í∞ú`))
      
      // Í∞Å Ï†úÎ™©Î≥ÑÎ°ú Í∞ÄÏû• ÏµúÍ∑º Í≤ÉÎßå ÎÇ®Í∏∞Í≥† ÎÇòÎ®∏ÏßÄ ÏÇ≠Ï†ú
      const templatesToKeep: any[] = []
      
      Object.entries(titleGroups).forEach(([title, items]) => {
        if (items.length > 1) {
          // ÏÉùÏÑ±Ïùº Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨ÌïòÏó¨ Í∞ÄÏû• ÏµúÍ∑º Í≤ÉÎßå Ïú†ÏßÄ
          const sorted = items.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
          templatesToKeep.push(sorted[0])
          console.log(`"${title}" Ï§ëÎ≥µ Ï†úÍ±∞: ${items.length}Í∞ú ‚Üí 1Í∞ú`)
        } else {
          templatesToKeep.push(items[0])
        }
      })
      
      // Ï†ïÎ¶¨Îêú ÌÖúÌîåÎ¶øÏúºÎ°ú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      dispatch({ type: 'SET_RECURRING_TEMPLATES', payload: templatesToKeep })
      
      // üî• Î°úÍ∑∏Ïù∏/ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê Î∂ÑÎ¶¨ Ï≤òÎ¶¨
      if (currentUser) {
        // Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: FirebaseÏóêÏÑúÎßå Í¥ÄÎ¶¨, Î°úÏª¨ Ïù∏Ïä§ÌÑ¥Ïä§ Ïû¨ÏÉùÏÑ± ÏïàÌï®
        console.log('üîó Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - ÌÖúÌîåÎ¶ø Ï†ïÎ¶¨ ÏôÑÎ£å, Firebase Ïù∏Ïä§ÌÑ¥Ïä§ Ïú†ÏßÄ')
      } else {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Ïù∏Ïä§ÌÑ¥Ïä§ Ïû¨ÏÉùÏÑ± + localStorage Ï†ÄÏû•
        console.log('üë§ ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - Ïù∏Ïä§ÌÑ¥Ïä§ Ïû¨ÏÉùÏÑ± ÏãúÏûë')
        const newInstances: SimpleRecurringInstance[] = []
        for (const template of templatesToKeep) {
          const instances = simpleRecurringSystem.generateInstances(template)
          newInstances.push(...instances)
        }
        dispatch({ type: 'SET_RECURRING_INSTANCES', payload: newInstances })
        
        try {
          localStorage.setItem('recurringTemplates', JSON.stringify(templatesToKeep))
          localStorage.setItem('recurringInstances', JSON.stringify(newInstances))
          console.log('‚úÖ Ï§ëÎ≥µ Ï†ïÎ¶¨ ÏôÑÎ£å - ÎÇ®ÏùÄ ÌÖúÌîåÎ¶ø:', templatesToKeep.length, 'Ïù∏Ïä§ÌÑ¥Ïä§:', newInstances.length)
        } catch (error) {
          console.error('‚ùå Ï†ïÎ¶¨ ÌõÑ Ï†ÄÏû• Ïã§Ìå®:', error)
        }
      }
    } else {
      console.log('‚úÖ Ï§ëÎ≥µÎêú ÌÖúÌîåÎ¶øÏù¥ ÏóÜÏäµÎãàÎã§.')
    }
  }

  const deleteRecurringTemplate = async (id: string) => {
    try {
      if (currentUser) {
        // Ï¶âÏãú UIÏóêÏÑú Ï†úÍ±∞ (ÎÇôÍ¥ÄÏ†Å ÏóÖÎç∞Ïù¥Ìä∏)
        dispatch({ type: 'DELETE_RECURRING_TEMPLATE', payload: id })
        console.log('‚úÖ Ï¶âÏãú UIÏóêÏÑú Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Ï†úÍ±∞:', id)
        
        // FirestoreÏóêÏÑú Ïã§Ï†ú ÏÇ≠Ï†ú
        await firestoreService.deleteRecurringTemplate(id, currentUser.uid)
        console.log('‚úÖ Î∞òÎ≥µ ÌÖúÌîåÎ¶ø Firestore ÏÇ≠Ï†ú ÏÑ±Í≥µ:', id)
      } else {
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê: Î©îÎ™®Î¶¨ÏóêÏÑú ÏÇ≠Ï†ú ÌõÑ localStorage Ï†ÄÏû•
        console.log('ÎπÑÎ°úÍ∑∏Ïù∏ Î™®Îìú: Î©îÎ™®Î¶¨ÏóêÏÑú Î∞òÎ≥µ ÌÖúÌîåÎ¶ø ÏÇ≠Ï†ú')
        dispatch({ type: 'DELETE_RECURRING_TEMPLATE', payload: id })
        
        // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎßå localStorage ÏÇ¨Ïö©
        console.log('üö´ ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - localStorage ÏÇ¨Ïö© ÎπÑÌôúÏÑ±Ìôî, Î©îÎ™®Î¶¨Îßå ÏóÖÎç∞Ïù¥Ìä∏')
      }
    } catch (error) {
      console.error('Î∞òÎ≥µ ÌÖúÌîåÎ¶ø ÏÇ≠Ï†ú Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'Î∞òÎ≥µ Ìï†Ïùº ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' })
    }
  }

  const generateRecurringInstances = () => {
    // üî• Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎäî FirebaseÏóêÏÑúÎßå Îç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨ (Î°úÏª¨ ÏÉùÏÑ± ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî)
    if (currentUser) {
      console.log('üö´üö´üö´ Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - Î°úÏª¨ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± ÏôÑÏ†Ñ Ï∞®Îã®!')
      return
    }
    
    // üî• Ï∂îÍ∞Ä Î≥¥Ìò∏: authLoading Ï§ëÏùº ÎïåÎèÑ Ï∞®Îã®
    if (authLoading) {
      console.log('‚è≥ Ïù∏Ï¶ù Î°úÎî© Ï§ë - Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± ÎåÄÍ∏∞')
      return
    }
    
    let allInstances: SimpleRecurringInstance[] = []
    
    state.recurringTemplates.filter(template => template.isActive).forEach(template => {
      try {
        const instances = simpleRecurringSystem.generateInstances(template)
        allInstances = [...allInstances, ...instances]
      } catch (error) {
        console.error(`ÌÖúÌîåÎ¶ø ${template.id} Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ïã§Ìå®:`, error)
      }
    })
    
    dispatch({ type: 'SET_RECURRING_INSTANCES', payload: allInstances })
    
    // Firestore Ï†ÑÏö© Î™®Îìú - localStorage ÏÇ¨Ïö© ÏïàÌï®
  }

  // Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§Î•º ÏùºÎ∞ò Ìï†ÏùºÎ°ú Î≥ÄÌôòÌïòÏó¨ Î∞òÌôò (Ï§ëÎ≥µ ÌÇ§ Î∞©ÏßÄ)
  const getRecurringTodos = (): Todo[] => {
    // üî•üî•üî• Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎäî Firebase Îç∞Ïù¥ÌÑ∞Îßå ÏÇ¨Ïö©, Î°úÏª¨ ÏÉùÏÑ± ÏôÑÏ†Ñ Í∏àÏßÄ!
    if (currentUser) {
      console.log('üö´üö´üö´ Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - Î∞òÎ≥µ Ìï†Ïùº Î°úÏª¨ ÏÉùÏÑ± ÏôÑÏ†Ñ Ï∞®Îã®! FirebaseÎßå ÏÇ¨Ïö©!')
      
      // Firebase state.recurringInstancesÎßå ÏßÅÏ†ë Î≥ÄÌôò
      const recurringTodos: Todo[] = []
      const seenIds = new Set<string>()
      
      console.log('üìä Firebase state.recurringInstances Í∞úÏàò:', state.recurringInstances.length)
      console.log('üìã Firebase Ïù∏Ïä§ÌÑ¥Ïä§ ID:', state.recurringInstances.map(i => `${i.id}(ÏôÑÎ£å:${i.completed})`))
      
      state.recurringInstances.forEach(instance => {
        const template = state.recurringTemplates.find(t => t.id === instance.templateId)
        if (template) {
          // üî• Firebase Îç∞Ïù¥ÌÑ∞Î•º ÏßÅÏ†ë TodoÎ°ú Î≥ÄÌôò (simpleRecurringSystem ÏÇ¨Ïö© ÏïàÌï®)
          const todo: Todo = {
            id: `recurring_${instance.id}`,
            title: template.title,
            description: template.description,
            completed: instance.completed, // ‚úÖ Firebase ÏôÑÎ£å ÏÉÅÌÉú Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
            priority: template.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†') ? 'urgent' : template.priority,
            type: template.type,
            dueDate: instance.date,
            createdAt: instance.createdAt,
            updatedAt: instance.updatedAt,
            completedAt: instance.completedAt, // ‚úÖ Firebase ÏôÑÎ£å ÏãúÍ∞Ñ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
            tags: [...(template.tags || [])],
            order: -1000, // Î∞òÎ≥µ Ìï†ÏùºÏùÑ Í∞ôÏùÄ Ïö∞ÏÑ†ÏàúÏúÑ ÎÇ¥ÏóêÏÑú ÏµúÏÉÅÎã®Ïóê ÌëúÏãú
            
            // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
            _isRecurringInstance: true,
            _instanceId: instance.id,
            _templateId: template.id
          } as Todo & {
            _isRecurringInstance: boolean
            _instanceId: string
            _templateId: string
          }
          
          if (template.title.includes('ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')) {
            console.log('üî• Firebase ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏßÅÏ†ë Î≥ÄÌôò:', {
              instanceCompleted: instance.completed,
              todoCompleted: todo.completed,
              instanceCompletedAt: instance.completedAt,
              todoCompletedAt: todo.completedAt
            })
          }
          
          if (!seenIds.has(todo.id)) {
            seenIds.add(todo.id)
            recurringTodos.push(todo)
          }
        }
      })
      
      console.log('‚úÖ Firebase ÏßÅÏ†ë Î≥ÄÌôò ÏôÑÎ£å:', recurringTodos.length, 'Í∞ú')
      return recurringTodos
    }
    
    // ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎßå Í∏∞Ï°¥ Î°úÏßÅ ÏÇ¨Ïö©
    console.log('üë§ ÎπÑÎ°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê - Í∏∞Ï°¥ Î°úÏßÅ ÏÇ¨Ïö©')
    console.log('üìä ÌòÑÏû¨ state.recurringInstances Í∞úÏàò:', state.recurringInstances.length)
    console.log('üìã Î™®Îì† Ïù∏Ïä§ÌÑ¥Ïä§ ID:', state.recurringInstances.map(i => `${i.id}(ÏôÑÎ£å:${i.completed})`))
    
    // üîß ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏÉÅÌÉú ÌôïÏù∏ (ÏÉÅÏÑ∏)
    const monthlyReport = state.recurringInstances.find(i => i.id === 'vCyWLYn3LuDq1nVUPSyE_2025-08-26')
    if (monthlyReport) {
      console.log('üîß getRecurringTodos - ÌòÑÏû¨ stateÏóêÏÑú ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†:', {
        id: monthlyReport.id,
        completed: monthlyReport.completed,
        updatedAt: monthlyReport.updatedAt
      })
    } else {
      console.log('‚ö†Ô∏è getRecurringTodos - stateÏóê ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†Í∞Ä ÏóÜÏùå. Ï†ÑÏ≤¥ Ïù∏Ïä§ÌÑ¥Ïä§ Ïàò:', state.recurringInstances.length)
    }
    
    const recurringTodos: Todo[] = []
    const seenIds = new Set<string>()
    
    state.recurringInstances.forEach(instance => {
      const template = state.recurringTemplates.find(t => t.id === instance.templateId)
      if (template) {
        const todo = simpleRecurringSystem.convertToTodo(instance, template)
        
        // Ï£ºÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† Î≥ÄÌôò Í≤∞Í≥º Î°úÍπÖ
        if (instance.id === 'PUH4xT3lVY5aK2vuQyUe_2025-08-21') {
          console.log(`üîÑ Ï£ºÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† convertToTodo Í≤∞Í≥º:`, {
            todoId: todo.id,
            completed: todo.completed,
            title: todo.title,
            dueDate: todo.dueDate,
            _isRecurringInstance: (todo as any)._isRecurringInstance,
            _instanceId: (todo as any)._instanceId
          })
        }
        
        // üî• ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† Î≥ÄÌôò Í≥ºÏ†ï Ï∂îÏ†Å
        if (instance.id === 'vCyWLYn3LuDq1nVUPSyE_2025-08-26') {
          console.log(`üî•üî•üî• ÏõîÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† convertToTodo Ï†ÑÌõÑ ÎπÑÍµê:`)
          console.log(`  ÏûÖÎ†• instance.completed: ${instance.completed} (${typeof instance.completed})`)
          console.log(`  ÏûÖÎ†• instance.completedAt: ${instance.completedAt}`)
          console.log(`  Ï∂úÎ†• todo.completed: ${todo.completed} (${typeof todo.completed})`)
          console.log(`  Ï∂úÎ†• todo.completedAt: ${todo.completedAt}`)
        }
        
        // Ï§ëÎ≥µ ÌÇ§ Í≤ÄÏÇ¨ Î∞è Î∞©ÏßÄ (Î∞òÎ≥µÌï†ÏùºÏùÄ Ïù∏Ïä§ÌÑ¥Ïä§ IDÎ•º Í∏∞Î∞òÏúºÎ°ú Í≥†Ïú†ÏÑ± Î≥¥Ïû•)
        const expectedId = `recurring_${instance.id}`
        if (todo.id !== expectedId) {
          console.warn(`‚ö†Ô∏è Î∞òÎ≥µ Ìï†Ïùº ID Î∂àÏùºÏπò Î∞úÍ≤¨: ${todo.id} ‚â† ${expectedId}`)
          todo.id = expectedId
          console.log(`‚úÖ Î∞òÎ≥µ Ìï†Ïùº ID ÏàòÏ†ï: ${todo.id}`)
        }
        
        if (seenIds.has(todo.id)) {
          console.warn(`‚ö†Ô∏è Î∞òÎ≥µ Ìï†Ïùº Ï§ëÎ≥µ ÌÇ§ Î∞úÍ≤¨: ${todo.id}, Ïù∏Ïä§ÌÑ¥Ïä§: ${instance.id}`)
          // Ïä§ÌÇµÌïòÏó¨ Ï§ëÎ≥µ Ï†úÍ±∞
          return
        }
        
        seenIds.add(todo.id)
        recurringTodos.push(todo)
      }
    })
    
    // Ï§ëÎ≥µ Î∞òÎ≥µ Ìï†Ïùº Ï†úÍ±∞
    const uniqueRecurringTodos = simpleRecurringSystem.removeDuplicateTodos(recurringTodos)
    
    console.log(`üìä getRecurringTodos ÏµúÏ¢Ö Í≤∞Í≥º: ${uniqueRecurringTodos.length}Í∞ú`)
    // Ï£ºÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏµúÏ¢Ö ÏÉÅÌÉú ÌôïÏù∏
    const finalWeeklyReport = uniqueRecurringTodos.find(t => t.title === 'Ï£ºÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥†')
    if (finalWeeklyReport) {
      console.log(`üéØ ÏµúÏ¢Ö Ï£ºÍ∞ÑÏóÖÎ¨¥Î≥¥Í≥† ÏÉÅÌÉú:`, {
        id: finalWeeklyReport.id,
        completed: finalWeeklyReport.completed,
        title: finalWeeklyReport.title
      })
    }
    
    return uniqueRecurringTodos
  }

  // Í∏∞Ï°¥ Ìï†ÏùºÎì§Ïóê order Í∞íÏùÑ Ï¥àÍ∏∞ÌôîÌïòÎäî Ìï®Ïàò
  const initializeOrderValues = () => {
    // ÏùºÎ∞ò Ìï†ÏùºÎì§
    const todosNeedingOrder = state.todos.filter(todo => 
      !todo.completed && (todo.order === undefined || todo.order === null)
    )
    
    // Î∞òÎ≥µÌï†ÏùºÎì§ÎèÑ Ìè¨Ìï®
    const recurringTodos = getRecurringTodos().filter(todo =>
      !todo.completed && (todo.order === undefined || todo.order === null)
    )
    
    const allTodosNeedingOrder = [...todosNeedingOrder, ...recurringTodos]
    
    if (allTodosNeedingOrder.length === 0) return
    
    console.log('üîß Order Í∞í Ï¥àÍ∏∞Ìôî ÎåÄÏÉÅ:', allTodosNeedingOrder.length, 'Í∞ú')
    
    // Ïö∞ÏÑ†ÏàúÏúÑÎ≥ÑÎ°ú Í∑∏Î£πÌôî
    const priorityGroups = {
      urgent: allTodosNeedingOrder.filter(t => t.priority === 'urgent'),
      high: allTodosNeedingOrder.filter(t => t.priority === 'high'),
      medium: allTodosNeedingOrder.filter(t => t.priority === 'medium'),
      low: allTodosNeedingOrder.filter(t => t.priority === 'low')
    }
    
    // Í∞Å Í∑∏Î£πÎ≥ÑÎ°ú ÏÉùÏÑ±Ïùº ÏàúÏúºÎ°ú Ï†ïÎ†¨Ìïú ÌõÑ order Í∞í Ìï†Îãπ
    const updatedTodos: Todo[] = []
    const updatedRecurringInstances: string[] = []
    
    Object.entries(priorityGroups).forEach(([priority, todos], priorityIndex) => {
      if (todos.length === 0) return
      
      // ÏÉùÏÑ±Ïùº ÏàúÏúºÎ°ú Ï†ïÎ†¨ (Ïò§ÎûòÎêú Í≤ÉÎ∂ÄÌÑ∞)
      const sortedTodos = todos.sort((a, b) => 
        new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
      )
      
      // order Í∞í Ìï†Îãπ (Ïö∞ÏÑ†ÏàúÏúÑÎ≥Ñ Î≤†Ïù¥Ïä§ Í∞í + Ïù∏Îç±Ïä§)
      const baseOrder = priorityIndex * 1000
      sortedTodos.forEach((todo, index) => {
        const orderValue = baseOrder + index * 10
        
        if ((todo as any)._isRecurringInstance) {
          // Î∞òÎ≥µÌï†ÏùºÏù∏ Í≤ΩÏö∞
          console.log('üîÑ Î∞òÎ≥µÌï†Ïùº order Ï¥àÍ∏∞Ìôî:', todo.title, '‚Üí', orderValue)
          const instanceId = (todo as any)._instanceId
          updatedRecurringInstances.push(instanceId)
          dispatch({
            type: 'UPDATE_RECURRING_INSTANCE',
            payload: {
              id: instanceId,
              updates: { order: orderValue }
            }
          })
        } else {
          // ÏùºÎ∞ò Ìï†ÏùºÏù∏ Í≤ΩÏö∞
          updatedTodos.push({
            ...todo,
            order: orderValue
          })
        }
      })
    })
    
    // ÏùºÎ∞ò Ìï†ÏùºÎì§ÏùÑ FirestoreÏôÄ Î°úÏª¨ ÏÉÅÌÉúÏóê Î∞òÏòÅ
    updatedTodos.forEach(async (todo) => {
      try {
        if (currentUser) {
          await firestoreService.updateTodo(todo.id, { order: todo.order }, currentUser.uid)
        }
        dispatch({ type: 'UPDATE_TODO', payload: { id: todo.id, updates: { order: todo.order } } })
      } catch (error) {
        console.error('Order Í∞í Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', todo.id, error)
      }
    })
    
    console.log('‚úÖ Order Ï¥àÍ∏∞Ìôî ÏôÑÎ£å:', updatedTodos.length, 'Í∞ú ÏùºÎ∞ò Ìï†Ïùº,', updatedRecurringInstances.length, 'Í∞ú Î∞òÎ≥µÌï†Ïùº')
  }

  // Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ® Ìï®Ïàò Ï∂îÍ∞Ä
  const forceRefresh = async () => {
    if (!currentUser) {
      console.log('‚ùå ÏÇ¨Ïö©ÏûêÍ∞Ä Î°úÍ∑∏Ïù∏ÌïòÏßÄ ÏïäÏùå')
      return
    }
    
    console.log('üîÑ Firestore Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ® ÏãúÏûë...')
    dispatch({ type: 'SET_LOADING', payload: true })
    
    try {
      // ÏßÅÏ†ë Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
      const todos = await firestoreService.getTodos(currentUser.uid)
      console.log('‚úÖ Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ® ÏÑ±Í≥µ:', todos.length, 'Í∞ú Ìï†Ïùº')
      dispatch({ type: 'SET_TODOS', payload: todos })
      dispatch({ type: 'SET_ERROR', payload: null })
    } catch (error: unknown) {
      console.error('‚ùå Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®:', error)
      dispatch({ type: 'SET_ERROR', payload: 'Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ®Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.' })
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false })
    }
  }

  // üö® Í∏¥Í∏â ÏàòÏ†ï: Firebase Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ ÏôÑÏ†Ñ Ïû¨ÏÉùÏÑ±
  const fixRecurringInstances = async () => {
    if (!currentUser) {
      console.log('‚ùå Î°úÍ∑∏Ïù∏ÌïòÏßÄ ÏïäÏùÄ ÏÇ¨Ïö©Ïûê')
      return
    }

    console.log('üö® Í∏¥Í∏â ÏàòÏ†ï: Firebase Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ ÏôÑÏ†Ñ Ïû¨ÏÉùÏÑ± ÏãúÏûë')

    try {
      // 1. Î™®Îì† Í∏∞Ï°¥ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÇ≠Ï†ú
      console.log('1Ô∏è‚É£ Î™®Îì† Í∏∞Ï°¥ Î∞òÎ≥µ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÇ≠Ï†ú Ï§ë...')
      const existingInstances = await firestoreService.getRecurringInstances(currentUser.uid)
      console.log(`ÏÇ≠Ï†úÌï† Ïù∏Ïä§ÌÑ¥Ïä§ Í∞úÏàò: ${existingInstances.length}`)

      for (const instance of existingInstances) {
        await firestoreService.deleteRecurringInstance(instance.id, currentUser.uid)
        console.log(`‚úÖ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÇ≠Ï†ú: ${instance.id}`)
      }

      // 2. Î™®Îì† ÌôúÏÑ± ÌÖúÌîåÎ¶øÏóê ÎåÄÌï¥ ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
      console.log('2Ô∏è‚É£ ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ï§ë...')
      const activeTemplates = state.recurringTemplates.filter(t => t.isActive)
      console.log(`ÌôúÏÑ± ÌÖúÌîåÎ¶ø Í∞úÏàò: ${activeTemplates.length}`)

      for (const template of activeTemplates) {
        console.log(`üîÑ ÌÖúÌîåÎ¶ø Ï≤òÎ¶¨: ${template.title} (monthlyDate: ${template.monthlyDate})`)

        // simpleRecurringSystemÏúºÎ°ú ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
        const newInstances = simpleRecurringSystem.generateInstances(template)
        console.log(`ÏÉùÏÑ±Îêú Ïù∏Ïä§ÌÑ¥Ïä§: ${newInstances.length}Í∞ú`)

        // FirebaseÏóê Ï†ÄÏû•
        for (const instance of newInstances) {
          const instanceData = {
            templateId: instance.templateId,
            date: instance.date,
            completed: false,
            createdAt: instance.createdAt,
            updatedAt: instance.updatedAt
          }

          const savedId = await firestoreService.addRecurringInstance(instanceData, currentUser.uid)
          console.log(`‚úÖ Ïù∏Ïä§ÌÑ¥Ïä§ Ï†ÄÏû•: ${savedId} - ${instance.date.toDateString()}`)
        }
      }

      // 3. Î°úÏª¨ ÏÉÅÌÉú ÏÉàÎ°úÍ≥†Ïπ®
      console.log('3Ô∏è‚É£ Î°úÏª¨ ÏÉÅÌÉú ÏÉàÎ°úÍ≥†Ïπ® Ï§ë...')
      await forceRefresh()

      console.log('‚úÖ Í∏¥Í∏â ÏàòÏ†ï ÏôÑÎ£å!')
      alert('‚úÖ Î∞òÎ≥µ Ìï†Ïùº Î¨∏Ï†úÍ∞Ä ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§!\nÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®Ìï¥Ï£ºÏÑ∏Ïöî.')

    } catch (error) {
      console.error('‚ùå Í∏¥Í∏â ÏàòÏ†ï Ïã§Ìå®:', error)
      alert('‚ùå ÏàòÏ†ï Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.')
    }
  }

  // ÏàòÎèô ÏÉàÎ°úÍ≥†Ïπ® Ìï®Ïàò (ÏÇ≠Ï†ú ÌõÑ Ìò∏Ï∂úÏö©)
  const manualRefresh = async () => {
    if (!currentUser) {
      console.log('‚ùå Î°úÍ∑∏Ïù∏ÌïòÏßÄ ÏïäÏùÄ ÏÇ¨Ïö©Ïûê')
      return
    }
    
    console.log('üîÑ ÏàòÎèô ÏÉàÎ°úÍ≥†Ïπ® ÏãúÏûë (ÏÇ≠Ï†ú ÌõÑ Ìò∏Ï∂ú)')
    try {
      const todos = await firestoreService.getTodos(currentUser.uid)
      console.log('‚úÖ ÏàòÎèô ÏÉàÎ°úÍ≥†Ïπ® ÏÑ±Í≥µ:', todos.length, 'Í∞ú Ìï†Ïùº')
      dispatch({ type: 'SET_TODOS', payload: todos })
    } catch (error) {
      console.error('‚ùå ÏàòÎèô ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®:', error)
    }
  }

  const value: TodoContextType = {
    ...state,
    addTodo,
    updateTodo,
    deleteTodo,
    toggleTodo,
    addSubTask,
    updateSubTask,
    deleteSubTask,
    toggleSubTask,
    syncWithFirestore,
    getTodayTodos,
    getWeekTodos,
    getMonthTodos,
    getOverdueTodos,
    getTomorrowTodos,
    getYesterdayIncompleteTodos,
    isYesterdayIncompleteTodo,
    updateTodoOrder,
    reorderTodos,
    getFilteredTodos,
    addRecurringTemplate,
    updateRecurringTemplate,
    deleteRecurringTemplate,
    generateRecurringInstances,
    getRecurringTodos,
    cleanupDuplicateTemplates,
    forceRefresh,
    manualRefresh,
    initializeOrderValues,
    fixRecurringInstances
  }

  // üö® Í∞úÎ∞úÏûê ÏΩòÏÜîÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Ï†ÑÏó≠ Ìï®ÏàòÎ°ú ÎÖ∏Ï∂ú
  useEffect(() => {
    if (typeof window !== 'undefined') {
      (window as any).fixRecurringInstances = fixRecurringInstances
    }
  }, [])

  return (
    <TodoContext.Provider value={value}>
      {children}
    </TodoContext.Provider>
  )
}

export const useTodos = () => {
  const context = useContext(TodoContext)
  if (context === undefined) {
    throw new Error('useTodos must be used within a TodoProvider')
  }
  return context
}