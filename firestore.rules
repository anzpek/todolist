rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper Functions
    function isOwner(data) {
      return request.auth.uid == data.ownerId;
    }
    
    function isSharedWith(data) {
      return request.auth.uid in data.sharedWithUids; 
    }

    function isEditor(data) {
      return request.auth.uid in data.editorUids;
    }

    // Top-level Users Collection (Profiles)
    match /users/{userId} {
      // Allow any authenticated user to read profiles (for searching by email)
      allow read: if request.auth != null;
      // Only the user can write their own profile
      allow write: if request.auth != null && request.auth.uid == userId;

      // Subcollection: Private Todos
      match /todos/{todoId} {
        // Strictly private: Only the owner can access
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
       match /recurring_templates/{templateId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      // 추가: recurringTemplates (camelCase - 실제 코드에서 사용하는 경로)
       match /recurringTemplates/{templateId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
       match /recurring_instances/{instanceId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      // 추가: recurringInstances (camelCase)
       match /recurringInstances/{instanceId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
       match /project_templates/{templateId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
       match /settings/{settingId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
       match /sharing_groups/{groupId} {
        // 읽기: 본인 소유 그룹만
        allow read: if request.auth != null && request.auth.uid == userId;
        
        // 생성/삭제: 본인 소유 그룹
        allow create, delete: if request.auth != null && request.auth.uid == userId;
        
        // 업데이트: 본인 소유거나, 초대 수락으로 멤버 추가 시
        // 임시로 모든 인증된 사용자에게 업데이트 허용 (초대 수락 지원)
        // TODO: Cloud Functions 사용하여 더 안전하게 처리
        allow update: if request.auth != null;
      }
      
      // 사용자 정의 공휴일
      match /custom_holidays/{holidayId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // 공유 알림 컬렉션 (권한 변경 알림 등)
    match /sharing_notifications/{notificationId} {
      // 생성: 인증된 사용자 (권한 변경 시 알림 발송)
      allow create: if request.auth != null;
      
      // 읽기/업데이트: 알림 대상자만
      allow read, update: if request.auth != null && resource.data.targetUid == request.auth.uid;
      
      // 삭제: 알림 대상자만
      allow delete: if request.auth != null && resource.data.targetUid == request.auth.uid;
    }

    // Top-level Shared Todos Collection
    match /shared_todos/{todoId} {
      // Read: Owner OR SharedWith (Viewer or Editor)
      allow read: if request.auth != null && (
          resource == null || 
          isOwner(resource.data) || 
          isSharedWith(resource.data)
      );

      // Create: Any authenticated user can create a shared task
      // Must ensure they set themselves as owner
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;

      // Update: Owner OR Editor
      // We check permission against the *existing* document (resource.data)
      // Special case: Allow update if the user is accepting an invitation (logic handled in client/service but Firestore needs to permit it)
      // Ideally, we'd have a server-side trigger, but for client-side join:
      // If user is NOT in sharedWithUids, they can't update.
      // So 'respondToInvitation' logic must rely on the Owner (or Editor) doing the update, OR we relax this rule.
      // Current implementation in firestoreService: respondToInvitation calls updateTodo.
      // If Acceptor calls it, they are not yet in sharedWithUids -> Permission Denied.
      // FIX: Allow update if user is in 'sharedWithUids' OR if they are adding themselves via a valid 'sharing_requests' (complex to validate in rules)
      // Alternative: The Acceptor calls 'respondToInvitation', which updates the Request status. 
      // Then, EITHER:
      // 1. The Acceptor is somehow allowed to write to shared_todos (bad/hard)
      // 2. We use a cloud function trigger (best, but maybe out of scope for this chat?)
      // 3. We assume the current user is Owner for testing? No.
      
      // Let's refine the Rule:
      // Allow update if:
      // 1. isOwner or isEditor
      // 2. OR, checking if the update effectively ONLY adds the current user to 'sharedWithUids' (and 'sharedWith') -- complex.
      // Since this is a specialized task, let's keep it simple for now:
      // We will allow update if the user is ALREADY an editor/owner.
      // If not, the invitation acceptance might need to fail or we need to relax the rule for 'self-add'.
      // For this 'Invitation' feature, the simplest robust way without Cloud Functions is:
      // The invitation itself is just a request. The Owner must approve it? No, user accepted.
      // Logic: User B accepts -> User B's UI tries to update shared_todos. Fails.
      
      // Temporary FIX for prototype: Relax update rule to allow any Auth user to update specific fields? No, unsafe.
      // Better: In `respondToInvitation`, we updated the Request.
      // Maybe we can have a rule: allow update if request.resource.data.diff(resource.data).affectedKeys() == ['sharedWith', 'sharedWithUids'].
      // And the new added UID is request.auth.uid.
      
      // Update: Owner OR SharedWith (Member)
      // Emergency Relaxed Rule: Allow any member to update. 
      allow update: if request.auth != null && (
          isOwner(resource.data) || 
          isSharedWith(resource.data)
      );

      // Delete: Owner OR Admin
      allow delete: if request.auth != null && (
          isOwner(resource.data) || 
          (resource.data.adminUids != null && request.auth.uid in resource.data.adminUids)
      );
    }
    
    // Sharing Requests Collection
    match /sharing_requests/{requestId} {
      // Create: Auth user can create (send invite)
      allow create: if request.auth != null && request.resource.data.fromUid == request.auth.uid;
      
      // Read: Sender or Receiver
      allow read: if request.auth != null && (
        resource.data.fromUid == request.auth.uid || 
        resource.data.toEmail == request.auth.token.email
      );
      
      // Update: Receiver can change status (Accept/Reject)
      allow update: if request.auth != null && (
        resource.data.toEmail == request.auth.token.email &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt'])
      );
      
      // Delete: Sender can cancel/delete
      allow delete: if request.auth != null && resource.data.fromUid == request.auth.uid;
    }
  }
}
